<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.png"/>
	<link rel="shortcut icon" href="/img/favicon.png">
	<meta name="baidu-site-verification" content="code-KLcpk3wnwR" />
	
			<title>趙天一ლ(ﾟдﾟლ)You know、You don’t know</title>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, user-scalable=no"
/>
<link rel="stylesheet" href="/css/mic_main.css" />
<link rel="stylesheet" href="/css/dropdownMenu.css" />
<!-- <script src="/js/live2d/autoload.js"></script> -->

<meta name="keywords" content="Zssaer JavaWeb TIANYI ZHAO" />

<noscript>
  <link rel="stylesheet" href="/css/noscript.css" />
</noscript>
<style type="text/css">
  /* body{
    background: url('https://zssaer.oss-cn-chengdu.aliyuncs.com/wallhaven-r7r551.jpg?x-oss-process=style/wallpaper') center 0 no-repeat;
    content: " ";
    position: fixed;
  } */
  body:before {
    content: " ";
    position: fixed;
    top: 0;
    background: url('https://zssaer.oss-cn-chengdu.aliyuncs.com/wallhaven-r7r551.jpg?x-oss-process=style/wallpaper') center 0 no-repeat;

    right: 0;
    bottom: 0;
    left: 0;
    background-size: cover;
  }
</style>

			    

    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.scrollex.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.scrolly.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/skel.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/util.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		<!-- Layouts -->


<!--  代码渲染  -->
<script src="/js/prism.js"></script>
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body
  class=""
  data-prismjs-copy="复制"
  data-prismjs-copy-error="请按Ctrl+C手动复制"
  data-prismjs-copy-success="复制成功!"
>
  <div class="mask-border"></div>
  <!-- Wrapper 外包 s-->
  <div id="wrapper" class="fade-in">
    <!-- Intro 头部显示 s -->
    <!-- Intro 头部显示 e -->
    <!-- Header 头部logo start -->
    <header id="header">
    <a href="/" class="logo">Refrain</a>
</header>
    <!-- Nav 导航条 start -->
    <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">Categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/JAVA/">JAVA</a></li><li><a class="category-link" href="/categories/Python/">Python</a></li><li><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li><a class="category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="AboutMe">
		                AboutMe
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="Wallpaper">
		                Wallpaper
		            </a>
		        </li>
		        
		        <li>
		            <a href="/bangumis/" title="Bangumis">
		                Bangumis
		            </a>
		        </li>
		        
						<li class="active">
							<a href="#s1">Other</a>
											<ul class="submenu">
													<li>
													<a class="category-link" href="/another/billiard.html">台球模拟V1.0</a>
												</li>
											</ul>
						</li>

            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Zssaer" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="git" href="https://gitee.com/Zssaer01" target="_blank" rel="noopener">
                            <i class="icon fa fa-git"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>
    <aside id="toc_menu"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">C++学习笔记（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">构造方法成员初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">拷贝赋值运算符函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">静态方法和静态成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.7.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-%E5%92%8C%E9%87%8D%E5%86%99-virtual%E3%80%81override"><span class="toc-number">1.1.8.</span> <span class="toc-text">虚函数 和重写- virtual、override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.9.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.10.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="toc-number">1.2.</span> <span class="toc-text">接口-interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">1.3.</span> <span class="toc-text">命名空间-namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8using-namespace"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用using namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">C++内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%88Stack-Memory%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">栈内存（Stack Memory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap-Memory%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">堆内存（Heap Memory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">栈内存和堆内存总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">1.4.4.</span> <span class="toc-text">全局&#x2F;静态存储区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">1.4.5.</span> <span class="toc-text">常量存储区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E4%B8%8E%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%E5%8C%BA-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.6.</span> <span class="toc-text">全局&#x2F;静态存储区与常量存储区 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDnew%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.4.7.</span> <span class="toc-text">重载new操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDdelete%E9%87%8D%E8%BD%BD%E7%AC%A6"><span class="toc-number">1.4.8.</span> <span class="toc-text">重载delete重载符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E9%87%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">统计堆内存中的使用量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E7%9A%84-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.6.</span> <span class="toc-text">库的 静态链接 &#x2F; 动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">静态链接方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">动态链接方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-Template"><span class="toc-number">1.7.</span> <span class="toc-text">模板(Template)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">模板的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.2.</span> <span class="toc-text">可变函数模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#define"><span class="toc-number">1.8.1.</span> <span class="toc-text">#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifdef"><span class="toc-number">1.8.2.</span> <span class="toc-text">#ifdef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">1.8.3.</span> <span class="toc-text"># if</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-Thread"><span class="toc-number">1.9.</span> <span class="toc-text">线程-Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B-%E5%92%8C-%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">运行线程 和 结束线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89-join"><span class="toc-number">1.9.3.</span> <span class="toc-text">等待线程（同步） - join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B-detach"><span class="toc-number">1.9.4.</span> <span class="toc-text">异步线程 - detach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.9.5.</span> <span class="toc-text">线程标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%BC%82%E6%AD%A5"><span class="toc-number">1.9.6.</span> <span class="toc-text">async异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">1.10.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81"><span class="toc-number">1.10.1.</span> <span class="toc-text">读取流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">字符读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%AF%BB%E5%8F%96"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">字节读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.10.2.</span> <span class="toc-text">输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">文件输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.3.</span> <span class="toc-text">复制操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.4.</span> <span class="toc-text">序列化操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC"><span class="toc-number">1.11.</span> <span class="toc-text">左值、右值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-Lvalue"><span class="toc-number">1.11.1.</span> <span class="toc-text">左值 (Lvalue)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC-Rvalue"><span class="toc-number">1.11.2.</span> <span class="toc-text">右值 (Rvalue)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.3.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">1.11.4.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%B3%95%E5%88%99%E3%80%81%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-number">1.11.5.</span> <span class="toc-text">三法则、五法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E5%9C%B0%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF"><span class="toc-number">1.12.</span> <span class="toc-text">优雅地处理函数返回错误</span></a></li></ol></li></ol></aside>
    <div id="main">
      
      <div
        class="post_page_title_img"
        style="
          height: 25rem;
          background-image: url(https://zssaer.oss-cn-chengdu.aliyuncs.com/wallhaven-xljpov.jpg?x-oss-process=style/wallpaper);
          background-position: center;
          background-repeat: no-repeat;
          background-size: cover;
          -moz-background-size: cover;
          overflow: hidden;
        "
      >
        <a href="#" style="padding: 4rem 4rem 2rem 4rem"
          ><h2 id="page-title">C++学习笔记（下）</h2></a
        >
      </div>
      
      <button id="toc_button" onclick="openTocSidebar()">文章导航</button>
      <!-- <div id="content_toc">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">C++学习笔记（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">构造方法成员初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">拷贝赋值运算符函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">静态方法和静态成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.7.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-%E5%92%8C%E9%87%8D%E5%86%99-virtual%E3%80%81override"><span class="toc-number">1.1.8.</span> <span class="toc-text">虚函数 和重写- virtual、override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.9.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.10.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="toc-number">1.2.</span> <span class="toc-text">接口-interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">1.3.</span> <span class="toc-text">命名空间-namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8using-namespace"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用using namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">C++内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%88Stack-Memory%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">栈内存（Stack Memory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap-Memory%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">堆内存（Heap Memory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">栈内存和堆内存总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">1.4.4.</span> <span class="toc-text">全局&#x2F;静态存储区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">1.4.5.</span> <span class="toc-text">常量存储区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E4%B8%8E%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%E5%8C%BA-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.6.</span> <span class="toc-text">全局&#x2F;静态存储区与常量存储区 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDnew%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.4.7.</span> <span class="toc-text">重载new操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDdelete%E9%87%8D%E8%BD%BD%E7%AC%A6"><span class="toc-number">1.4.8.</span> <span class="toc-text">重载delete重载符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E9%87%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">统计堆内存中的使用量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E7%9A%84-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.6.</span> <span class="toc-text">库的 静态链接 &#x2F; 动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">静态链接方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">动态链接方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-Template"><span class="toc-number">1.7.</span> <span class="toc-text">模板(Template)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">模板的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.2.</span> <span class="toc-text">可变函数模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#define"><span class="toc-number">1.8.1.</span> <span class="toc-text">#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifdef"><span class="toc-number">1.8.2.</span> <span class="toc-text">#ifdef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">1.8.3.</span> <span class="toc-text"># if</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-Thread"><span class="toc-number">1.9.</span> <span class="toc-text">线程-Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B-%E5%92%8C-%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">运行线程 和 结束线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89-join"><span class="toc-number">1.9.3.</span> <span class="toc-text">等待线程（同步） - join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B-detach"><span class="toc-number">1.9.4.</span> <span class="toc-text">异步线程 - detach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.9.5.</span> <span class="toc-text">线程标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%BC%82%E6%AD%A5"><span class="toc-number">1.9.6.</span> <span class="toc-text">async异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">1.10.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81"><span class="toc-number">1.10.1.</span> <span class="toc-text">读取流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">字符读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%AF%BB%E5%8F%96"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">字节读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.10.2.</span> <span class="toc-text">输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">文件输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.3.</span> <span class="toc-text">复制操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.4.</span> <span class="toc-text">序列化操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC"><span class="toc-number">1.11.</span> <span class="toc-text">左值、右值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-Lvalue"><span class="toc-number">1.11.1.</span> <span class="toc-text">左值 (Lvalue)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC-Rvalue"><span class="toc-number">1.11.2.</span> <span class="toc-text">右值 (Rvalue)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.3.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">1.11.4.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%B3%95%E5%88%99%E3%80%81%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-number">1.11.5.</span> <span class="toc-text">三法则、五法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E5%9C%B0%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF"><span class="toc-number">1.12.</span> <span class="toc-text">优雅地处理函数返回错误</span></a></li></ol></li></ol>
            </div>     -->

      <!-- Post -->
      <div class="typo" style="padding: 3rem"><h1 id="C-学习笔记（下）"><a href="#C-学习笔记（下）" class="headerlink" title="C++学习笔记（下）"></a>C++学习笔记（下）</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>类是用户自定义的类型，如果程序中要用到类，必须提前说明，或者使用已存在的类（别人写好的类、标准库中的类等），C++语法本身并不提供现成的类的名称、结构和内容。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student&#123;
public:
    &#x2F;&#x2F;成员变量
    char *name;
    int age;
    float score;
    &#x2F;&#x2F;成员函数
    void say()&#123;
        cout&lt;&lt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>类定义在”class”关键字之后，方法和属性的默认修饰符是”private”。</li>
<li>类定义在”struct”关键字之后，方法和属性的默认修饰符是”public”。</li>
</ol>
<p>注意在类定义的最后有一个分号<code>;</code>，它是类定义的一部分，表示类定义结束了，不能省略。</p>
<p>类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</p>
<p>在创建对象时，class 关键字可要可不要，但是出于习惯我们通常会省略掉 class 关键字，例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student LiLei;  &#x2F;&#x2F;正确
Student LiLei;  &#x2F;&#x2F;同样正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>除了创建单个对象，还可以创建对象数组：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Student allStu[100];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该语句创建了一个 allStu 数组，它拥有100个元素，每个元素都是 Student 类型的对象。</p>
<h3 id="构造方法成员初始化"><a href="#构造方法成员初始化" class="headerlink" title="构造方法成员初始化"></a>构造方法成员初始化</h3><p>C++中构造方法初始化成员参数的方法有很多，可能大伙最熟悉的是直接在构造方法中初始化：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student&#123;
    std::string name;
    int age;
public:
    Student()&#123;
        name &#x3D; &quot;default&quot;;
        age &#x3D; 10;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而在C++中最方便的初始化方法其实是：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student&#123;
    std::string name;
    int age;
public:
    Student() : name(&quot;default&quot;),age(10) &#123;
        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在构造方法请求参数括号后 使用<code>:</code>符号，按 成员参数名(值)来进行一一初始化。<strong>注意这里的赋值顺序需要按照成员参数的顺序，否则编译器会报错。</strong></p>
<p>这种的构造器初始化的好处不仅仅只是为了便捷，最重要的是 不需要将初始化的值进行一次实例化，而是直接将值注入，提升了程序的性能。</p>
<p>举个例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test&#123;
public:
    Test()&#123;
        std::cout &lt;&lt; &quot;This is default test!&quot; &lt;&lt; std::endl;
    &#125;
    Test(std::string name)&#123;
        std::cout &lt;&lt; &quot;This is &quot; &lt;&lt; name &lt;&lt; &quot; test!&quot; &lt;&lt; std::endl;
    &#125;
&#125;;
class Student&#123;
    Test test;
public:
    Student()&#123;
		test &#x3D; Test(&quot;My&quot;);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面当调用Student空构造器函数后，看似会执行Test的有参构造器。但其实最终的输出是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">This is default test!
This is My test!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>因为Student中的test在初始化之前就触发了空参构造器，所以这种赋值会额外在内存中创建一个临时对象，浪费性能。</p>
<p>而使用上面的方式来初始化：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test&#123;
public:
    Test()&#123;
        std::cout &lt;&lt; &quot;This is default test!&quot; &lt;&lt; std::endl;
    &#125;
    Test(std::string name)&#123;
        std::cout &lt;&lt; &quot;This is &quot; &lt;&lt; name &lt;&lt; &quot; test!&quot; &lt;&lt; std::endl;
    &#125;
&#125;;
class Student&#123;
    Test test;
public:
    Student() : test(Test(&quot;My&quot;)) &#123; &#x2F;&#x2F; 或者 test(&quot;My&quot;)
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这种输出就只会输出：</p>
<pre class="line-numbers language-none"><code class="language-none">This is My test!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数是 C++ 类的一个特殊成员函数，它在对象的生命周期结束时自动被调用，常常用于执行任何必要的清理操作。</p>
<p>析构函数的主要目的是释放对象可能已分配的资源，如动态内存、文件句柄、数据库连接等。</p>
<p>析构函数的声明如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ClassName</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>析构函数在以下情况下特别重要：</p>
<ol>
<li><strong>资源管理</strong>：当类的对象中 持有如动态内存、文件、网络连接等资源时，析构函数确保在对象销毁时释放这些资源。</li>
<li><strong>与智能指针配合</strong>：例如，<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 使用析构函数来确保所指向的对象在适当的时候被删除。</li>
</ol>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝行为通常发生在同类的赋值上。如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 13;
int b &#x3D; a;  &#x2F;&#x2F;b由a拷贝创建而来。

Person a &#x3D; (XXX);
Person b &#x3D; a;  &#x2F;&#x2F;同类的复制赋值，会触发拷贝构造函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同类的拷贝赋值行为 就会 触发类中的拷贝构造函数。定义这个函数后便可以自定义同类拷贝时的操作。</p>
<p>拷贝构造函数的典型声明如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ClassName</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">ClassName</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，<code>other</code> 是要被复制的对象的引用。</p>
<p>注意事项：</p>
<ol>
<li><p><strong>深拷贝与浅拷贝</strong>：默认的拷贝构造函数执行浅拷贝，这可能不适用于具有动态分配内存或资源的类。在这种情况下，你需要提供自定义的拷贝构造函数来执行深拷贝。</p>
</li>
<li><p><strong>规则 of Three/Five</strong>：如果你为类定义了拷贝构造函数、拷贝赋值运算符或析构函数，那么你通常也需要定义其他两个。这被称为 “Rule of Three”。在 C++11 及以后，这个规则扩展到五个，包括移动构造函数和移动赋值运算符，称为 “Rule of Five”。</p>
</li>
<li><p><strong>删除拷贝构造函数</strong>：在某些情况下，可能不希望类的对象被拷贝赋值。那么，可以选择在类中删除拷贝构造函数：</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ClassName(const ClassName&amp; other) &#x3D; delete;
...
&#x2F;&#x2F; ClassName a
ClassName b &#x3D; a;  &#x2F;&#x2F; Error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

</li>
</ol>
<h3 id="拷贝赋值运算符函数"><a href="#拷贝赋值运算符函数" class="headerlink" title="拷贝赋值运算符函数"></a>拷贝赋值运算符函数</h3><p>与拷贝构造函数基本上含义一样，即拷贝同类函数，使用“ = ”赋值到另外一个同类对象上。</p>
<p>但<strong>两者区别是 拷贝赋值运算符 只是 作用于已经定义的对象上，而 拷贝构造函数则是生成一个未定义的对象。</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Person a <span class="token operator">=</span> <span class="token punctuation">(</span>XXX<span class="token punctuation">)</span><span class="token punctuation">;</span>
Person b <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment">//触发拷贝构造函数。</span>
Person c<span class="token punctuation">;</span>
c <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//触发拷贝赋值运算符函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>拷贝赋值运算符函数的典型声明和定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class ClassName &#123;
public:
    ClassName&amp; operator&#x3D;(const ClassName&amp; other) &#123;
        &#x2F;&#x2F; 拷贝 other 的内容到 *this
        return *this;
    &#125;
    &#x2F;&#x2F; ...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同样如果不期望触发拷贝赋值运算符操作的话，可以在类中删除它：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ClassName<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> ClassName<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="静态方法和静态成员变量"><a href="#静态方法和静态成员变量" class="headerlink" title="静态方法和静态成员变量"></a>静态方法和静态成员变量</h3><p>在 C++ 中，使用 <code>static</code> 关键字来声明一个静态成员函数。它是类的成员函数的一种特殊类型。静态方法属于整个类而不是类的实例，因此可以在不创建类的对象的情况下调用（前提该静态元素是在public访问修饰符下定义的）。</p>
<p>静态方法可以访问类的静态成员变量，但不能访问非静态成员变量，因为非静态成员变量是与类的实例相关联的。</p>
<p>非静态方法是可以访问类中的静态方法和静态变量的。</p>
<p>public的静态方法的调用方式是通过类名加作用域运算符 <code>::</code> 来调用，而不是通过类的对象来调用。这意味着静态方法不需要通过类的实例进行调用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyClass &#123;
public:
    static int staticVariable;
    static void staticMethod() &#123;
        std::cout &lt;&lt; &quot;This is a static method.&quot; &lt;&lt; std::endl;
    &#125;
&#125;
int main()&#123;
    MyClass::staticVariable &#x3D; 10;
    MyClass::staticMethod();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而位于非public下的静态成员（protected、private访问修饰符下），在外部不能直接访问，只能通过派生类、自身访问。</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>C++的父类叫做基类，子类叫做派生类。当然叫做父类、子类都无关系，概率相同。</p>
<p>C++的类继承 是在派生类名后 使用<code>:</code>。但和大多数语言不同的是 C++的类继承带有访问修饰符。默认未声明的情况下，即private继承。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base &#123;
...
&#125;;

class DerivedPublic : public Base &#123;
    &#x2F;&#x2F; public 继承，基类的 public 成员在派生类中保持 public 访问权限
&#125;;

class DerivedProtected : protected Base &#123;
    &#x2F;&#x2F; protected 继承，基类的 public 成员在派生类中变为 protected 访问权限
&#125;;

class DerivedPrivate : Base &#123;
    &#x2F;&#x2F; private 继承，默认继承方式, 基类的 public 成员在派生类中变为 private 访问权限
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>所以为了保证继承的结构相似性，基本上都是使用的public继承，额外加上public访问修饰符。</strong></p>
<p>此外<strong>C++支持多重继承</strong>，这点和Python一样。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Derived : public Base1, public Base2 &#123;
    &#x2F;&#x2F; Derived 类继承了 Base1 和 Base2
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是，多重继承可能会引入一些问题，例如 “<strong>菱形继承</strong>“（Diamond Inheritance）问题。即继承的基类中出现重复的继承关系，它在类的继承关系中形成了一个菱形的结构，导致了一些二义性和资源浪费的情况。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;
public:
    int x;
&#125;;

class B : public A &#123;
public:
    int y;
&#125;;

class C : public A &#123;
public:
    int z;
&#125;;

&#x2F;&#x2F;基类B、C都继承于A类。相当于继承了两个A类。出现重复继承关系，即菱形继承。
class D : public B, public C &#123;
public:
    int w;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>冗余数据：在类 <code>D</code> 中存在两份 <code>A</code> 类的成员，造成了冗余的数据存储。</li>
<li>二义性：由于存在两份相同的成员 <code>x</code>，当在类 <code>D</code> 中访问 <code>x</code> 成员时，编译器无法确定是从 <code>B</code> 类部分还是 <code>C</code> 类部分访问，从而导致了二义性。</li>
</ol>
<p>为了解决菱形继承问题，C++ 提供了<strong>虚拟继承</strong>（virtual inheritance）的概念。通过在继承时使用 <code>virtual</code> 关键字，将其设定为虚拟继承，可以消除菱形继承引起的二义性问题，并确保在继承体系中只有一个共享的基类子对象。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class A &#123;
public:
    int x;
&#125;;

class B : public virtual A &#123;
public:
    int y;
&#125;;

class C : public virtual A &#123;
public:
    int z;
&#125;;

class D : public B, public C &#123;
public:
    int w;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样在类 <code>D</code> 中只会有一个共享的 <code>A</code> 类子对象。此时访问 <code>x</code> 成员时就不会出现二义性。虚拟继承确保了基类 <code>A</code> 在继承体系中只有一份共享的拷贝，从而避免了冗余数据的问题。就虚函数一样，虚拟继承也会生成一个虚拟表（vtable）来处理虚拟继承的问题，会造成内存需求上升。但正常情况开发下，这点性能损失可以忽略不计。</p>
<h3 id="虚函数-和重写-virtual、override"><a href="#虚函数-和重写-virtual、override" class="headerlink" title="虚函数 和重写- virtual、override"></a>虚函数 和重写- virtual、override</h3><p>C++中要实现继承子类中，重写父类的方法 ，即方法重载。就得将 对应父类方法进行虚函数设置：</p>
<p>在方法前加上修饰符 <code>virtual</code>，表名该函数为虚函数，子类可对其进行重写操作。</p>
<p>和其他语言，like Java相似，子类方法在进行重写操作时需要添加 override修饰符。C++的override修饰符置于方法（）后，它不是硬性要求，只是对其IDE进行识别。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;
public:
    &#x2F;&#x2F; 虚函数,该方法可被后代重写
    virtual void doSomething()&#123;  
        std::cout &lt;&lt; &quot;Person&quot; &lt;&lt; std::endl;
    &#125;; 
&#125;;
class Techer : public Person&#123;
public:
    &#x2F;&#x2F; override修饰符,IDE识别该方法为重写方法。非硬性要求。
    void doSomething() override &#123;  
        std::cout &lt;&lt; &quot;Techer&quot; &lt;&lt; std::endl;
    &#125;; 
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用虚函数，编译器会生成一个虚拟表（vtable）来处理虚函数的处理，会造成内存需求上升。但正常情况开发下，这点性能损失可以忽略不计。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>C++中的单例模式设计如下:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton
&#123;
private:
    &#x2F;&#x2F; 阻止直接创建
	Singleton()
	&#123;
	&#125;
	float IFloat()
	&#123;
		return m_Xxx;
	&#125;
	float m_Xxx &#x3D; 0.5f;

public:
	static Singleton&amp; getInstance()
	&#123;
		static Singleton instance;  &#x2F;&#x2F;将单例实体放置在获取方法中，而不是常规的private中，并没有实际影响。
		return instance;
	&#125;
	&#x2F;&#x2F; 移除赋值修饰符
	Singleton(const Singleton&amp;) &#x3D; delete;
    &#x2F;&#x2F; 单例方式静态直接调用内部方法
	static float Float() &#123; return getInstance().IFloat(); &#125;
&#125;;

int main()
&#123;
    Singleton&amp; singleton &#x3D; Singleton::getInstance();  &#x2F;&#x2F;单例方式获取的是引用
    float s &#x3D; Singleton::Float();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口-interface"></a>接口-interface</h2><p><strong>C++中没有像JAVA这种语言内置有Interface类型。在 C++ 中，你可以使用抽象类和纯虚函数来定义接口</strong>。接口是一种规范，它定义了一组方法（成员函数）的名称和参数列表，但没有实际的实现。具体的类可以通过继承接口并实现其中的<strong>纯虚函数</strong>来实现接口的功能。所以纯虚函数构成的类即接口类。</p>
<p>所谓纯虚函数，就是函数声明 为 0的虚函数，like <code>virtual ReturnType functionName(XXX) = 0</code>。</p>
<p>下面是在 C++ 中编写接口的基本步骤：</p>
<ol>
<li>定义接口类：创建一个抽象类，其中包含一组纯虚函数，这些纯虚函数将组成接口的方法。在 C++ 中，通过在函数声明后面添加 <code>= 0</code> 来将其定义为纯虚函数。</li>
<li>继承接口类：创建具体的类，并继承上述定义的接口类。在具体类中，必须实现接口类中的所有纯虚函数，否则具体类也将成为抽象类。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

&#x2F;&#x2F; 定义接口类
class Interface &#123;
public:
    virtual void doSomething() &#x3D; 0; &#x2F;&#x2F; 纯虚函数，构成接口
    virtual void doAnotherThing() &#x3D; 0; &#x2F;&#x2F; 纯虚函数，构成接口
&#125;;

&#x2F;&#x2F; 具体类A，实现了接口类Interface
class ClassA : public Interface &#123;
public:
    void doSomething() override &#123;
        std::cout &lt;&lt; &quot;ClassA: Doing something.&quot; &lt;&lt; std::endl;
    &#125;

    void doAnotherThing() override &#123;
        std::cout &lt;&lt; &quot;ClassA: Doing another thing.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

&#x2F;&#x2F; 具体类B，实现了接口类Interface
class ClassB : public Interface &#123;
public:
    void doSomething() override &#123;
        std::cout &lt;&lt; &quot;ClassB: Doing something.&quot; &lt;&lt; std::endl;
    &#125;

    void doAnotherThing() override &#123;
        std::cout &lt;&lt; &quot;ClassB: Doing another thing.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    ClassA objA;
    ClassB objB;
    Interface* ptrA &#x3D; &amp;objA;
    Interface* ptrB &#x3D; &amp;objB;
    &#x2F;&#x2F; 通过指向接口的指针调用具体类的方法，实现了多态
    ptrA-&gt;doSomething();
    ptrB-&gt;doAnotherThing();
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间-namespace"></a>命名空间-namespace</h2><p><code>namespace</code> 是一种用于组织代码和避免命名冲突的机制。它允许将一组相关的函数、类、变量等定义在一个逻辑上独立的命名空间中，从而将它们与其他代码隔离开来。从用在h头文件中。</p>
<p>通过使用 <code>namespace</code>，你可以在代码中创建一个新的命名空间，并在该命名空间中定义函数、类、常量等，这些定义将会放在这个命名空间中。这样可以避免在全局作用域中产生命名冲突，同时也提供了更好的代码组织和模块化。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace name &#123;
    &#x2F;&#x2F; 命名空间内的代码定义
    &#x2F;&#x2F; 可以包含函数、类、常量等
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>命名空间常常使用在h头文件中，用来将相关代码组织在一起：当你有一组相关的函数、类、常量等，可以将它们放在同一个命名空间中，使代码更加结构化和清晰。并且避免了调用多个库而导致函数冲突的情况。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; ModuleA.h
namespace ModuleA &#123;
    void func();
&#125;
&#x2F;&#x2F; ModuleB.h
namespace ModuleB &#123;
    void func();
&#125;
&#x2F;&#x2F; main.cpp
#include &quot;ModuleA.h&quot;
#include &quot;ModuleB.h&quot;
int main() &#123;
    ModuleA::func();
    ModuleB::func();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>namespace使用 命名空间名称+<code>::</code>+对应 变量和函数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;
    A::func();
    B::func();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="使用using-namespace"><a href="#使用using-namespace" class="headerlink" title="使用using namespace"></a>使用using namespace</h3><p>由于include导入了含有namespace定义的h头文件，在调用对应namespace的函数时，我们不得不在函数前加上 <code>命名空间名::</code> ，like <code>std::cout</code> 、<code>std::string</code>。<br>为了方便，可以使用using namespace 命名空间名，让c++编译器默认使用该namespace中的对应函数，从而不需要使用 前置”命名空间名::”调用对应函数了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using namespace std;

int main()&#123;
    cout &lt;&lt; &quot;Hello，world&quot; &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>using 操作符 遵守作用域，如果将其定义在局部作用域下，那么范围将只作用在作用域下。</p>
<h2 id="C-内存区域"><a href="#C-内存区域" class="headerlink" title="C++内存区域"></a>C++内存区域</h2><p>C++的内存区域主要有4个。</p>
<p>分别是：</p>
<ol>
<li>栈内存 （局部变量和函数调用的内存区域，C++自动管理）</li>
<li>堆内存（<code>new</code>操作符在堆上手动分配内存，由程序员代码手动管理）</li>
<li>全局/静态存储区（全局变量、静态变量和常量，在程序整个生命周期内都一直存在）</li>
<li>常量存储区（存储字符串常量和其他常量数据，在程序整个生命周期内都一直存在）</li>
</ol>
<h3 id="栈内存（Stack-Memory）"><a href="#栈内存（Stack-Memory）" class="headerlink" title="栈内存（Stack Memory）"></a>栈内存（Stack Memory）</h3><p>栈内存（Stack Memory）的特点：</p>
<ul>
<li>栈内存是用于存储局部变量和函数调用的内存区域。</li>
<li>在程序运行时，每个线程都会维护一个称为”栈”的内存空间。</li>
<li>函数调用过程中，函数的局部变量和参数会被分配在栈上，并在函数调用结束时自动释放。</li>
<li>栈内存的分配和释放是由编译器自动完成的，它的速度很快，因为栈上的内存分配和释放遵循后进先出（LIFO）的原则，只需简单地移动指针即可完成。</li>
<li>栈的大小通常有限，一般在几MB到几GB之间，具体取决于系统和编译器设置。这意味着栈上分配的内存不适合存储大型对象或长期存活的对象。</li>
</ul>
<p>在C++代码中，栈内存主要体现在以下几个方面：</p>
<ol>
<li><p>局部变量：在函数或代码块内部声明的变量都被视为局部变量，并且这些变量通常存储在栈上。当函数或代码块执行完毕时，栈上的局部变量会自动被销毁，其内存被释放。这种自动的内存管理确保了局部变量在其作用域内有效，且不会产生内存泄漏。</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

void myFunction() &#123;
    int x &#x3D; 10; &#x2F;&#x2F; x是一个局部变量，存储在栈上
    std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; std::endl;
&#125; &#x2F;&#x2F; 在函数执行完毕后，x会被自动销毁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>函数调用和返回：函数调用过程中，函数的返回地址和局部变量等信息被保存在栈帧中。当函数执行完毕后，栈帧会被弹出，将控制权返回给调用函数。</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;
    int sum &#x3D; add(5, 3); &#x2F;&#x2F; add函数调用时，sum和add函数的返回地址等信息被保存在栈帧中
    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; &#x2F;&#x2F; 栈帧被弹出，控制权返回给main函数
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>在这些场景中，栈内存的分配和释放是自动管理的，无需程序员手动干预，这样可以确保内存的正确使用和释放，避免了很多内存管理问题。然而，需要注意栈内存的有限性，特别是在处理递归或大型数据结构时，可能会导致栈溢出错误。</p>
<h3 id="堆内存（Heap-Memory）"><a href="#堆内存（Heap-Memory）" class="headerlink" title="堆内存（Heap Memory）"></a>堆内存（Heap Memory）</h3><p>堆内存（Heap Memory）的特点：</p>
<ul>
<li>堆内存用于存储动态分配的数据，它的分配和释放是由程序员手动控制的。</li>
<li>堆内存提供了更大的内存空间，用于存储对象和数据结构，其大小受系统内存的限制。</li>
<li>在堆上分配内存需要使用特定的操作符，如<code>new</code>（在C++）或<code>malloc</code>（在C语言）来请求内存空间。</li>
<li>释放堆内存需要使用<code>delete</code>（在C++）或<code>free</code>（在C语言）来手动释放已分配的内存，以避免内存泄漏。</li>
<li>堆上的内存分配和释放比栈内存更慢，因为它需要更复杂的内存管理操作。但是堆内存允许对象的生存期在函数调用之外，因此可以在堆上存储长期生存的对象。</li>
</ul>
<p>在C++代码中，栈内存主要体现在：</p>
<p>在C++中，我们可以使用<code>new</code>操作符来在堆上分配内存，使用<code>delete</code>操作符来释放已分配的内存。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

int main() &#123;
    &#x2F;&#x2F; 在堆上动态分配一个整数
    int* pInt &#x3D; new int;
    *pInt &#x3D; 10;
    std::cout &lt;&lt; &quot;Value at pInt: &quot; &lt;&lt; *pInt &lt;&lt; std::endl;

    &#x2F;&#x2F; 在堆上动态分配一个整数数组
    int* pIntArray &#x3D; new int[5];
    for (int i &#x3D; 0; i &lt; 5; ++i) &#123;
        pIntArray[i] &#x3D; i;
    &#125;
    
    delete pInt;
    delete[] pIntArray;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是，堆内存的分配和释放是比较慢的，因为它涉及到更复杂的内存管理。因此，在使用堆内存时，应该仔细考虑何时分配和释放内存，以避免不必要的内存分配和泄漏。</p>
<p>推荐在使用堆内存时，使用智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>）等RAII（资源获取即初始化）技术来自动管理内存，以确保在不再需要时自动释放内存，避免忘记手动释放内存的问题。</p>
<h3 id="栈内存和堆内存总结"><a href="#栈内存和堆内存总结" class="headerlink" title="栈内存和堆内存总结"></a>栈内存和堆内存总结</h3><p>栈内存和堆内存是程序运行时内存分配的两个主要区域。<strong>栈内存用于存储局部变量和函数调用的内存区域，其分配和释放由编译器自动管理，速度较快但容量有限。堆内存用于动态分配数据，其分配和释放由程序员手动控制，允许存储较大的对象和长期生存的对象，但速度较慢。正确地管理栈内存和堆内存对于程序的性能和稳定性至关重要。</strong></p>
<h3 id="全局-静态存储区"><a href="#全局-静态存储区" class="headerlink" title="全局/静态存储区"></a>全局/静态存储区</h3><ul>
<li>全局存储区用于存储全局变量、静态变量和常量。</li>
<li>在程序的整个生命周期内都存在，即从程序启动到程序结束，这些变量的值保持不变。</li>
<li>全局变量和静态变量在程序开始运行时被初始化，而常量在编译时被确定。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

&#x2F;&#x2F; 全局变量
int globalVar &#x3D; 10;

&#x2F;&#x2F; 静态变量
static int staticVar &#x3D; 20;

void func() &#123;
    &#x2F;&#x2F; 静态局部变量
    static int count &#x3D; 0;
    count++;
    std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl;
&#125;

int main() &#123;
    &#x2F;&#x2F; 常量
    const int constantVar &#x3D; 30;

    std::cout &lt;&lt; &quot;Global Variable: &quot; &lt;&lt; globalVar &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Static Variable: &quot; &lt;&lt; staticVar &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Constant Variable: &quot; &lt;&lt; constantVar &lt;&lt; std::endl;

    func(); &#x2F;&#x2F; 调用func函数多次，静态局部变量的值会一直增加

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a>常量存储区</h3><ul>
<li>常量存储区用于存储字符串常量和其他常量数据。</li>
<li>在程序的整个生命周期内都存在，其值在编译时就已经确定，不可更改。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

int main() &#123;
    const char* str &#x3D; &quot;Hello, World!&quot;; &#x2F;&#x2F; 字符串常量

    std::cout &lt;&lt; str &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="全局-静态存储区与常量存储区-区别"><a href="#全局-静态存储区与常量存储区-区别" class="headerlink" title="全局/静态存储区与常量存储区 区别"></a>全局/静态存储区与常量存储区 区别</h3><p>全局/静态存储区 的内容 在程序运行前初始化为0，而常量存储区 的内容在编译时就已经确定，不可在运行时修改。</p>
<h3 id="重载new操作符"><a href="#重载new操作符" class="headerlink" title="重载new操作符"></a>重载new操作符</h3><p><code>new</code>是一个关键字，和<code>sizeof</code>一样，我们无法修改其具体功能。<code>new</code>主要做三件事：分配空间、初始化对象、返回指针。调用<code>operator new</code>分配空间。</p>
<p>但其实new在堆内存中分配内存，实际上是调用的C语言中的 malloc函数。在很多情况下，我们可以重载new操作符，并加上分配堆内存大小Log操作，方便为某些操作做对应的优化。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* operator new(size_t size)
&#123;
    std::cout &lt;&lt; &quot;堆内存中分配了内存，大小为：&quot; &lt;&lt; size &lt;&lt; &quot;个字节\n&quot;;
    return malloc(size);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每当有操作调用new，在堆内存中分配内存时，它都会打印出分配的大小。当然使用智能指针也同样会触发new操作。</p>
<h3 id="重载delete重载符"><a href="#重载delete重载符" class="headerlink" title="重载delete重载符"></a>重载delete重载符</h3><p>delete的本质也是调用了free函数。和重载new操作符一样。我们也可以重载delete操作符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void operator delete(void* memory, size_t size)
&#123;
    std::cout &lt;&lt; &quot;堆内存中释放了内存，大小为：&quot; &lt;&lt; size &lt;&lt; &quot;个字节\n&quot;;
    free(memory);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="统计堆内存中的使用量"><a href="#统计堆内存中的使用量" class="headerlink" title="统计堆内存中的使用量"></a>统计堆内存中的使用量</h3><p>利用上重载new重载符和delete操作符后，可以编写一个struct or class，并利用静态static全局创建，来动态统计当前堆内存中的使用量：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct AllocationMetrics
&#123;
    uint32_t TotalAllocated &#x3D; 0;
    uint32_t TotalFreed &#x3D; 0;
    
    uint32_t CurrentUsage() &#123; return TotalAllocated - TotalFreed; &#125;
&#125;
static AllocationMetrics s_AllocationMetrics;  &#x2F;&#x2F; 创建AllocationMetrics全局对象

void* operator new(size_t size)
&#123;
   s_AllocationMetrics.TotalAllocated +&#x3D; size;  &#x2F;&#x2F;每次分配在堆内存中分配内存大小统计
    return malloc(size);
&#125;
void* operator new[](std::size_t size) &#123;
    s_AllocationMetrics.TotalAllocated +&#x3D; size;  
    return std::malloc(size);
&#125;
void operator delete(void* memory, size_t size)
&#123;
    s_AllocationMetrics.TotalFreed +&#x3D; size;  &#x2F;&#x2F;每次清除堆内存大小统计
    free(memory);
&#125;
void operator delete[](void* memory, std::size_t size) noexcept &#123;
    s_AllocationMetrics.TotalFreed +&#x3D; size;
    std::free(memory);
&#125;
static void printMemoryUsage()
&#123;
    std::cout &lt;&lt; &quot;堆内存使用情况：&quot; &lt;&lt; s_AllocationMetrics.CurrentUsage() &lt;&lt; &quot;个字节\n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建了一个AllocationMetrics struct ，当每次调用 new 和delete 进行堆内存操作时都进行统计。调用printMemoryUsage函数即可打印当前堆内存情况。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string string <span class="token operator">=</span> <span class="token string">"ZSSAER"</span><span class="token punctuation">;</span>
    <span class="token function">printMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>XXX<span class="token operator">></span> xxx <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>XXX<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printMemoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C的字符串其实是由单个字符构成，实现字符串的原理就是创建字符的数值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"XXX"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"XXX"</span><span class="token punctuation">;</span>  <span class="token comment">//这种形式更加简洁，实际开发中常用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在C语言中，字符串总是以<code>&#39;\0&#39;</code>作为结尾，所以<code>&#39;\0&#39;</code>也被称为字符串结束标志，或者字符串结束符。（这个\0也会占字符大小，所以定义字符串的大小的时也要size+1）</p>
<blockquote>
<p><code>&#39;\0&#39;</code>是 ASCII 码表中的第 0 个字符，英文称为 NUL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。</p>
</blockquote>
<p>上面创建的str1和str2字符串实际上 在结尾处都自动补充上来”\0”，它们实际上 是存储的是“XXX\0”。</p>
<p>字符串长度计算函数<code>strlen</code>实际是以<code>\0</code>为结尾来计算的，所以当字符串中中间包含<code>\0</code>时，那么只能计算<code>\0</code>前面的字符长度：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;  
int main()&#123;
    char str[] &#x3D; &quot;xx\0xxx&quot;;
    long len &#x3D; strlen(str); \\ 2
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>C++的字符串创建通常有下面几种:</p>
<ol>
<li><p>字符数组/字符串指针创建方式:<br> 你可以使用字符数组来创建字符串，数组以空字符 <code>\0</code> 结尾，表示字符串的结束。例如：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> <code>[]</code>中不包含大小时，会默认根据初始化的字符大小来设置。</p>
<p> 加入const的目的是保证字符串作为常量，确保字符串后续不能被修改。</p>
<p> 为了更好的动态内存分配和灵活性，实际上通常使用字符串指针创建。</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const char* str1 &#x3D; &quot;Hello, World!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>C++ 字符串类 <code>std::string</code>：<br> C++ 标准库提供了 <code>std::string</code> 类，它封装了字符串的处理操作，并自动管理内存。你可以使用以下方式创建 <code>std::string</code> 对象：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string str2 <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>使用 <code>std::string</code> 构造函数：<br> 你可以使用 <code>std::string</code> 类的构造函数来创建字符串，接受不同类型的参数，例如：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">str3</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从 C 风格字符串创建</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">str4</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重复字符 'A' 10 次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<ol start="4">
<li><p>使用字符串连接运算符 <code>+</code>：<br> 你可以通过连接两个字符串来创建一个新的字符串，使用 <code>+</code> 运算符来实现：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string str5 <span class="token operator">=</span> <span class="token string">"Hello, "</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string str6 <span class="token operator">=</span> <span class="token string">"World!"</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string result <span class="token operator">=</span> str5 <span class="token operator">+</span> str6<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<ol start="5">
<li><p>使用字符串字面量：<br> 在 C++11 及以上版本中，你可以使用原始字符串字面量来创建字符串，它以 <code>R</code> 开头，并使用括号括起来，方便处理包含多行和转义字符的字符串：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string str7 <span class="token operator">=</span> <span class="token raw-string string">R"(This is a raw string literal \n Hello)"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<p>无论你选择哪种方式，实际上字符串都会在字符串尾部加上结束符 <code>\0</code> ，这是 C 风格字符串的要求。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const char* str &#x3D; &quot;XXX&quot;;
char* str1 &#x3D; &quot;xxx&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上述两个字符串看看起来都是一样的，第一个是使用字符串指针创建的字符串常量，而第二个则只是由字符串指针创建的字符串。</p>
<p>顾名思义，str这个字符串常量定义后肯定不能被后续修改。但是对于str1这个字符串呢？</p>
<p>其实str1看起来并未被标记为常量，是能被后续修改的，但记住 使用指针创建的字符串只是指向一段字符串的，<strong>你依然不能后续修改它</strong>。由于缺少const标记，一些IDE不会显示后续修改操作错误。但是某些C++编译器则会出现异常。所以通常情况下都是使用的const char*创建方式。</p>
<p><strong>所有的字符串，都是通过在堆内存中进行分配内存大小实现的，而左值的对象是通过 对其的指针。</strong>所以创建字符串都相当于调用new操作，在堆内存中分配了内存空间。所以字符串使用都会造成程序运行效率变低。</p>
<p>但在C++11中，使用<code>std::string</code>创建小于等于15字符的字符串，在Release编译模式下，会自动开启一种叫SSO小字符串优化操作，会将小字符串直接在栈缓存中直接创建，而不再在堆内存中创建。所以对于16以下字符大小的字符串不需要特别在意其对程序的运行效率影响。</p>
<h2 id="库的-静态链接-动态链接"><a href="#库的-静态链接-动态链接" class="headerlink" title="库的 静态链接 / 动态链接"></a>库的 静态链接 / 动态链接</h2><p>和其他语言一样，编写C++项目也会面临使用很多第三方的库。所谓库，就是写好的现有的，成熟的，可以复用的代码。<strong>现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常</strong>。</p>
<p>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。</p>
<p>所谓静态、动态是指链接。将一个程序编译成可执行程序的步骤：</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/16201601-66b55a2f0ec74c5b8a773a0e1904e812.png"></p>
<p>简而言之，库的使用有两种（即库的连接方式）：</p>
<ol>
<li>静态链接：使用静态库（.a、.lib），在是因为在链接阶段，会将汇编生成的目标文件（.o）与引用到的库（.a、.lib）一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。 <strong>使用的库也会被打包在一个可执行文件中，运行不需要外置dll文件。</strong></li>
<li>动态链接：使用动态库（.so、.dll），动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。</li>
</ol>
<p>两种链接方式的优缺点：</p>
<ol>
<li><p>静态链接：通常这种方式打包生成的可执行文件往往比较大，空间浪费。但是由于不需要动态获取外置库内容，所以程序运行效率高于动态链接。</p>
<p> <img src="E:/JavaLeaningDoc/picture/16201613-1320ec57feb24583a6b1294421c323b8.png"></p>
</li>
<li><p>动态链接：<strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，<strong>增量更新</strong>。</p>
<p> <img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/16201613-110ca9e0fd684281b3ee6d9bd9bebd78.png"></p>
</li>
</ol>
<h3 id="静态链接方法"><a href="#静态链接方法" class="headerlink" title="静态链接方法"></a>静态链接方法</h3><p>以使用GLFW(一个OpenGL的开源库)为例，官网下载对应的二进制包。</p>
<p>我们要使用的是 将其中 include文件夹（内含h头文件，表示该库可以调用内容），一个lib二进制文件夹（内含lib静态库文件，库种核心文件）。</p>
<p>结构如下：</p>
<pre class="line-numbers language-none"><code class="language-none">include\
	GLFW\
		glfw3.h
GLFW\
	glfw3.lib
	glfw3dll.lib
	glfw3.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>在解决方案文件夹下创建一个dependencies文件夹，用于放置第三方库文件，将上面两个文件夹放置进去。</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/20230802000209.png"></p>
<p>VS设置解决方案属性中，在“C/C++”选项中，将include文件导入附加包含目录中:</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/20230802000643.png"></p>
<p>注意这里使用$(SolutionDir)，避免使用绝对地址。以免其他电脑使用项目配置出错。</p>
<p>将包含h头文件的目录配置进包含目录中后，这时IDE就能顺利识别到该库的h文件了，便可以在自己项目中include使用了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;GLFW&#x2F;glfw3.h&gt;

int main() &#123;
	int g &#x3D; glfwInit();
	std::cout &lt;&lt; g &lt;&lt; std::endl;
	std::cin.get();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里由于include文件下还有一级GLFW文件夹，所以导入的是<code>GLFW/glfw3.h</code>。为什么，不再C++附加包含目录中直接配置到include下面的GLFW文件夹呢？</p>
<p>因为在程序中不一定只会包含这一个第三方库，所以只导入include，后续单独加上各种库的文件夹，这种方式更符合规范。</p>
<p>按Ctrl+F7编译，VS提示成功后，执行生成操作时，会弹出错误。这是因为h头部文件只是一个声明库 中可调用函数的文件，不包含其中函数的内部操作代码部分（相当于一个只是Java中的接口）。相当于第三方库函数调用内容是空的，在链接时自然会提示报错。</p>
<p>我们需要在将库的核心 静态库文件导入进来。在VS设置解决方案属性中，在“连接器”选项下的“常规”选项中，在附加库目录中 添加lib二进制文件夹：</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/20230802002007.png"></p>
<p>然后到”输入”选项卡中，在附加依赖性 中添加 使用的lib文件：</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/20230802002236.png"></p>
<p>这里由于在附加库目录中添加了文件夹地址，所以这里直接输入文件名即可被链接器寻找到。</p>
<p>这时，再重新执行生成操作，就会发现被成功的链接上了。生成的可执行文件由于静态链接的原因 也变大了不少。</p>
<p>自此便成功使用静态链接方法使用了第三方GLFW的静态库（.lib、.a）。</p>
<h3 id="动态链接方法"><a href="#动态链接方法" class="headerlink" title="动态链接方法"></a>动态链接方法</h3><p>所谓动态链接，即在程序运行过程中加载外部动态dll库。所以dll文件需要放置在可执行文件旁，这种方式常用于大型项目中。</p>
<p>步骤基本上静态类似。</p>
<p>类似的添加C++ 附加包含目录，以便寻找h头文件。</p>
<p>类似的添加链接器中的 附加依赖项。但不同的是需要添加对于的动态库文件，而不是静态库文件，GLFW中动态库文件是<code>glfw3dll.lib</code>，不然编译链接将依然按照静态链接处理。</p>
<p>生成解决方案后，动态链接的项目不能直接运行，这时运行的话会提示程序找不到XXX.dll文件。我们需要额外的将其动态库文件dll放置在生成的可执行文件旁才可以运行。</p>
<p>如果时动态库也是一个自己的项目，需要不断更新修改的话，那么相当于每次都需要再把最新的动态库Dll文件拷贝过来。</p>
<p>为了简便流程，我们可以在主项目中设置生成后自动复制动态库操作。</p>
<p>打开主项目的属性页。打开“生成事件”下的“生成后事件”选项卡，在其命名行中 加入以下内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcopy /y /d <span class="token string">"动态库项目地址\<span class="token variable"><span class="token variable">$(</span>IntDir<span class="token variable">)</span></span>动态库名.dll"</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>OutDir<span class="token variable">)</span></span>"</span>

xcopy /y /d <span class="token string">"..\MathLibrary\<span class="token variable"><span class="token variable">$(</span>IntDir<span class="token variable">)</span></span>MathLibrary.dll"</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>OutDir<span class="token variable">)</span></span>"</span>  // 复制相对路径下上级文件夹下的MathLibrary下的对应编辑生成地址中的MathLibrary.dll到本项目输出目录下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里的动态库项目地址如果也在同一个仓库中,可以就近使用相对路径”../“方式。“$(IntDir)”函数将自动寻找编译生成的地址。</p>
<h2 id="模板-Template"><a href="#模板-Template" class="headerlink" title="模板(Template)"></a>模板(Template)</h2><p>C++中的Template类似于C#、Java语言中的泛型。但是它不至于泛型限制的作用，功能更加强大，可以用来在程序编译中生成对应的代码。</p>
<p>C++ 模板（Template）是一种通用的编程机制，允许在编译时根据类型参数生成通用的代码。通过使用模板，可以实现一次编写多次使用的代码，从而提高代码的重用性和灵活性。C++ 模板使得模板元编程成为可能，这是一种使用模板在编译时执行计算的技术，从而产生更高效的代码。</p>
<h3 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h3><p>C++ 中的模板主要分为两种类型：</p>
<ol>
<li><p><strong>函数模板（Function Template）</strong>：函数模板允许定义通用的函数，其中的某些类型或值是参数化的。函数模板使用 <code>template</code> 关键字来声明，并使用一个或多个模板参数来表示参数化的类型或值。</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
T max(T a, T b) &#123;
    return (a &gt; b) ? a : b;
&#125;

...
max(12,13);  &#x2F;&#x2F;根据函数参数，编译器自动将其T设定为int类型
max(12.3,13.5);  &#x2F;&#x2F;根据函数参数，编译器自动将其T设定为double类型
max&lt;float&gt;(12.3f,13.5f)  &#x2F;&#x2F;手动设置T为float类型，函数参数必须要求float类型。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 其中<typename T>  中的typename 可替换为class。T即泛型的变量名，可根据实际自由更改命名。位于模板下方的函数使用模板中的泛指自动 将其函数标记为函数模板。</p>
</li>
<li><p><strong>类模板（Class Template）</strong>：类模板允许定义通用的类，其中的某些成员或成员函数是参数化的。类模板也使用 <code>template</code> 关键字来声明，并使用一个或多个模板参数来表示参数化的类型或值。</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
class Stack &#123;
private:
    T arr[100];
    int top;

public:
    Stack() : top(-1) &#123;&#125;
    void push(T val) &#123; arr[++top] &#x3D; val; &#125;
    T pop() &#123; return arr[top--]; &#125;
    bool isEmpty() const &#123; return top &#x3D;&#x3D; -1; &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 上述代码定义了一个类模板 <code>Stack</code>，它是一个栈结构，其中的元素类型是模板参数 <code>T</code>。在使用时，可以根据不同的类型来实例化不同类型的栈对象。</p>
</li>
</ol>
<p>模板中的泛型不只是可以定义一个，可以定义更多：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T, typename N, int O&gt;  &#x2F;&#x2F;T和N都接受任何类型元素，而O只能接受int类型元素。
T function(T a, N b, O c)
&#123;
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于指定了类型的元素，相当起到了替换作用。</p>
<p>C++ 模板还可以与 STL 容器和算法一起使用。标准模板库（STL）提供了许多通用容器，如 <code>std::vector</code>、<code>std::map</code> 等，可以处理任何数据类型。</p>
<h3 id="可变函数模板"><a href="#可变函数模板" class="headerlink" title="可变函数模板"></a>可变函数模板</h3><p>可变模板参数是 C++11 引入的一个功能，允许模板接受任意数量和类型的参数。这为模板编程提供了更大的灵活性，特别是在需要处理不确定数量的类型时。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename... Args&gt;
void myFunction(Args... args);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可变模板参数使用省略号 <code>...</code> 来表示。   虽然使用可变模板参数，但是仍然需要在 参数类型定义中和 参数使用时添加”…”。</p>
<p>递归使用：</p>
<p>和可变函数原因，一般可变函数模板单独出现，至少还有一个参数。<strong>可变函数模板，常用作构建递归函数，并且还要 重载一个函数的模板函数 。</strong>：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 当递归到只有一个参数的时候
template&lt;typename T&gt;
void print(T t) &#123;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
&#125;


template&lt;typename T, typename... Args&gt;
void print(T t, Args... args) &#123;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    print(args...);
&#125;

int main() &#123;
    print(1, 2.2, &quot;three&quot;, &#39;4&#39;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面函数模板是一个万用类型打印函数。</p>
<p>通常可变函数模板中，要有一个常规参数，用作处理单独事物。而可变函数是不能用来直接处理的，只能用来递归。递归还需要再重载一个无可变参数的模板，用以最后递归 的调用。</p>
<p><strong>结合 <code>sizeof...</code> 运算符</strong>使用:</p>
<p>C++11 还引入了 <code>sizeof...</code> 运算符，它可以用来直接计算可变模板参数的数量：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename... Args&gt;
void printCount(Args... args) &#123;
    std::cout &lt;&lt; sizeof...(Args) &lt;&lt; std::endl;  &#x2F;&#x2F; 计算类型数量
    std::cout &lt;&lt; sizeof...(args) &lt;&lt; std::endl;  &#x2F;&#x2F; 计算参数数量
&#125;

int main() &#123;
    printCount(1, 2.2, &quot;three&quot;, &#39;4&#39;);  &#x2F;&#x2F; 输出 4 两次
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>











<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>C++ 预处理（Preprocessor）是 C++ 编译过程中的一个重要阶段，它在实际编译之前对源代码进行一系列文本替换和宏展开等处理。预处理器的主要任务是处理以井号 <code>#</code> 开头的预处理指令，并根据这些指令对源代码进行修改和处理，生成预处理后的代码。其中我们常用的开头编写的 #include就是一个预处理命名。</p>
<p>这些预处理指令是由编译器在编译之前处理的，所以称为预处理。它的优先级高于 普通编写的代码。</p>
<p>预处理器的工作是在实际的编译过程之前进行的，它会对整个源代码进行处理，并生成一个新的经过宏展开和文本替换的临时代码文件。这个临时文件会被传递给编译器进行后续的编译和生成目标代码。 </p>
<p>预处理器常见的指令包括：</p>
<ul>
<li><code>#include</code>：用于包含其他头文件。</li>
<li><code>#define</code>：用于定义宏。</li>
<li><code>#ifdef</code>、<code>#ifndef</code>、<code>#else</code>、<code>#endif</code>：用于条件编译。</li>
<li><code>#ifdef</code>、<code>#ifndef</code>、<code>#else</code>、<code>#elif</code>、<code>#endif</code>：用于条件编译。</li>
<li><code>#pragma</code>：用于给编译器传递特定的编译指令。</li>
</ul>
<p>预处理器还支持宏替换、宏展开等功能。宏是一种简单的文本替换，可以用 <code>#define</code> 定义宏，并在代码中使用。预处理器会在编译之前将宏展开为其对应的文本，从而实现宏的替换功能。</p>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p>对于反复使用的代码，可以使用<code>#define</code>预处理命名来 用指定语句 代替。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define CIN_GET std::cin.get()
#define LOG(X) std::cout &lt;&lt; X &lt;&lt; std::endl

...
int i &#x3D; 1;
LOG(i);  &#x2F;&#x2F; as std::cout &lt;&lt; i &lt;&lt; std::endl
CIN_GET;  &#x2F;&#x2F; as std::cin.get()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>#define 宏名 代替语句</p>
</blockquote>
<p>使用define来代替一些语句的方式，是C++ 宏的一种常用的形式。</p>
<p>对于多行的语句，显然 #define 不能直接接受换行内容。</p>
<p>只需要在每个换行前 加上反斜杠符号 <code>\</code>(Enter换行的转义)，预处理器就能将其归纳为一个预处理语句下的内容了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAIN int main() &#123; \
    std::cin.get();\
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h3 id="ifdef"><a href="#ifdef" class="headerlink" title="#ifdef"></a>#ifdef</h3><p><code>#ifdef</code> 是预处理指令之一，用于条件编译，需要于<code>#endif</code>一起使用。它的作用是在编译阶段根据条件来判断是否包含或排除某些代码块，从而实现根据不同情况选择性地编译特定的代码片段。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifdef 宏名
&#x2F;&#x2F; 条件为真时要编译的代码
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>预处理将会自动寻找相关宏名，它们可以是在文件中使用#define定义的，也可以是在编译器的命令行参数或者IDE的预处理器中定义的。如果宏名存在或者返回 真则 执行后续内容，否则不执行后续，跳转到#endif下。</p>
<p>VS中预处理器定义 设置在 解决方案设置下。</p>
<p>下面是一段简单的例子:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

#ifdef DEBUG_MODE
#define NOW_MODE std::cout &lt;&lt; &quot;In debug mode now.&quot; &lt;&lt; std::endl
#else
#define NOW_MODE std::cout &lt;&lt; &quot;In release mode now.&quot; &lt;&lt; std::endl
#endif

int main() &#123;
    NOW_MODE;
    std::cin.get();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的DEBUG_MODE 需要在 IDE中的预处理器定义 中在DEBUG模式下设置。 上面当程序编译位于不同模式下，NOW_MODE宏都会有不同的定义。</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/202384.PNG"></p>
<p>另外预处理语句同样 也可以位于普通代码的内部，并非限制于文件头部位置。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;
#ifdef DEBUG_MODE
    std::cout &lt;&lt; &quot;Debug mode is enabled.&quot; &lt;&lt; std::endl;
#else
    std::cout &lt;&lt; &quot;Debug mode is disabled.&quot; &lt;&lt; std::endl;
#endif
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同样类似于<code>#ifdef</code>的条件预处理语句还有 如 <code>#ifndef</code>、<code>#else</code>、<code>#elif</code>、<code>#endif</code> 等，使用方法大差不差。</p>
<h3 id="if"><a href="#if" class="headerlink" title="# if"></a># if</h3><p>上面简绍的<code>#ifdef</code> 有个缺陷，就是只能接受宏名，不能判断对应的参数。</p>
<p>而<code>#if</code>则更加合理。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#if DEBUG_MODE &#x3D;&#x3D; 1
#define NOW_MODE std::cout &lt;&lt; &quot;In debug mode now.&quot; &lt;&lt; std::endl
#else
#define NOW_MODE std::cout &lt;&lt; &quot;In release mode now.&quot; &lt;&lt; std::endl
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里在 IDE中的预处理器定义 中在DEBUG模式下设置 <code>DEBUG_MODE=1</code>即可（中间不能有空格）。</p>
<p><code>#if</code>能判断值，让人更加理解，而<code>#ifdef</code>只能单纯判断宏的存在与否。</p>
<h2 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程-Thread"></a>线程-Thread</h2><p>在C++ 11之前，C++ 标准库并没有提供线程支持。</p>
<p>但从 C++11 开始，标准库引入了 <code>&lt;thread&gt;</code> 头文件，为多线程编程提供了原生支持。这使得在 C++ 中创建和管理线程变得相对简单。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>使用 <code>std::thread</code> 类可以创建一个新的线程。你只需提供一个函数或可调用对象，它将在新线程中执行。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>

<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from thread!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>myFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对象名(线程操作函数 or 可调用对象)</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待线程完成</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>thread除了提供已经有的函数以外，可以提供lambda函数。</p>
<h3 id="运行线程-和-结束线程"><a href="#运行线程-和-结束线程" class="headerlink" title="运行线程 和 结束线程"></a>运行线程 和 结束线程</h3><p>和Java等语言那种需要手动调用start方法来 启动线程操作 不一样。</p>
<p>C++ 中创建的Thread线程对象是自动启动的，不需要手动调用方法启动。</p>
<p><strong>在结束方面，也会Java等语言不同。C++中 Thread需要额外声明它的结束，否则运行完毕的Thread将不会被内存清理，就如同在堆内存中创建对象需要 delete一样。</strong></p>
<p><strong>通常需要附加上 join（同步结束） 、 detach（异步结束），这取决于对该线程的运行要求。</strong></p>
<h3 id="等待线程（同步）-join"><a href="#等待线程（同步）-join" class="headerlink" title="等待线程（同步） - join"></a>等待线程（同步） - join</h3><p>用于现代CPU都是多核心多线程，所以现代程序 默认情况下不同线程操作是同时运行的，各自不会等待，称之为异步。</p>
<p>当某些场景需要等待某个线程运行完成，才进行接下来的操作，称之为线程同步。这种场景通常用于金融交易、购票等等。</p>
<p>Thread对象可以使用join函数，请求主线程 等待 其线程完成。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">...
int main() &#123;
    std::thread t(myFunction);
    t.join();  &#x2F;&#x2F; 主线程堵塞，等待t中线程完成操作。t中线程 后才能继续主线程操作。
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="异步线程-detach"><a href="#异步线程-detach" class="headerlink" title="异步线程 - detach"></a>异步线程 - detach</h3><p><code>detach()</code>: 允许线程独立运行，不需要主线程等待其完成。虽然线程被创建出来默认 就是异步运行的，但你依然需要对其使用它，以示运行完毕后清理该线程。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">...
int main() &#123;
    std::thread t(myFunction);
    t.detach();  &#x2F;&#x2F; 异步结束清理线程
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="线程标识符"><a href="#线程标识符" class="headerlink" title="线程标识符"></a>线程标识符</h3><p>每个线程都有一个唯一的标识符，可以使用 <code>std::thread::id</code> 类型和 <code>std::thread::get_id()</code> 函数来获取。</p>
<h3 id="async异步"><a href="#async异步" class="headerlink" title="async异步"></a>async异步</h3><p><code>std::async</code> 是 C++11 标准库中的一个功能，它位于future库，下它允许你异步地执行函数，并可能在另一个线程上运行它。这为并发编程提供了一个简单而强大的工具，特别是当你想并行执行某些任务并获取结果时。</p>
<p>使用 <code>std::async</code> 启动一个异步任务非常简单。你只需传递要执行的函数和其参数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;future&gt;

int compute() &#123;
    return 42;  &#x2F;&#x2F; Some computation
&#125;

int main() &#123;
    std::future&lt;int&gt; result &#x3D; std::async(compute);
    int value &#x3D; result.get();  &#x2F;&#x2F; Blocks until the result is ready
    std::cout &lt;&lt; &quot;Computed value: &quot; &lt;&lt; value &lt;&lt; std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>返回值</strong>:<code>std::async</code> 返回一个 <code>std::future</code> 对象，<code>std::future</code> 是 C++11 标准库中的一个模板类，它表示一个异步操作的未来结果。</p>
<p>调用 <code>std::future::get()</code> 会阻塞，直到结果准备好。</p>
<p><strong>启动策略</strong>: <code>std::async</code> 可以接受一个可选的启动策略参数，该参数决定任务是立即启动还是延迟启动：</p>
<ul>
<li><code>std::launch::async</code>: 任务在一个新线程上异步启动。</li>
<li><code>std::launch::deferred</code>: 任务被延迟，直到你调用 <code>std::future::get()</code> 或 <code>std::future::wait()</code> 时才执行，并在当前线程上执行。</li>
</ul>
<p>如果你不主动提供启动策略，那么 <code>std::async</code> 可以自由选择策略。但多半会选择<code>std::launch::deferred</code>策略，所以相当于不会执行异步操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::future&lt;int&gt; result &#x3D; std::async(std::launch::async, compute);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>异常处理</strong>: 如果异步任务抛出一个异常，该异常会被存储并在调用 <code>std::future::get()</code> 时重新抛出。所以使用get必要的时候,使用try - catch.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int compute() &#123;
    throw std::runtime_error(&quot;An error occurred!&quot;);
    return 42;
&#125;

int main() &#123;
    std::future&lt;int&gt; result &#x3D; std::async(compute);
    try &#123;
        int value &#x3D; result.get();
    &#125; catch (const std::exception&amp; e) &#123;
        std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="读取流"><a href="#读取流" class="headerlink" title="读取流"></a>读取流</h3><h4 id="字符读取"><a href="#字符读取" class="headerlink" title="字符读取"></a>字符读取</h4><p>在 C++ 中，读取字符文件通常使用 <code>&lt;fstream&gt;</code> 库，该库提供了 <code>ifstream</code> 类来支持文件输入操作。以下是使用 <code>ifstream</code> 读取文件的基本步骤：</p>
<ol>
<li><p><strong>打开文件</strong></p>
<p> 创建一个 <code>ifstream</code> 对象并使用 <code>open</code> 方法打开文件。你也可以在构造函数中直接提供文件名来打开文件。</p>
 <pre class="line-numbers language-cPP" data-language="cPP"><code class="language-cPP">std::ifstream file(&quot;filename.txt&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 其中接受的参数是文件存储位置+文件名，如果没有存储位置则表示读取当前CPP文件下指定文件。</p>
</li>
<li><p><strong>检查文件是否成功打开</strong></p>
<p> ifstream对象的<code>is_open</code>函数可以检测文件是否成功打开，如果返回false则表示文件打开错误。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to open the file."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// or handle the error appropriately</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>读取文件</strong></p>
<p> 读取文件类似于cin，分为行读取，单词读取（以空格分割读取）和字符读取。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// getline读取一行字符</span>
std<span class="token double-colon punctuation">::</span>string line<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// >>读取单词</span>
std<span class="token double-colon punctuation">::</span>string word<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>file <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">char</span> ch<span class="token punctuation">;</span>
<span class="token comment">// get函数读取字符</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ch<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>关闭文件</strong></p>
<p> 和其他语言一样，使用IO流操作后都需要进行关闭操作。</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">file.close();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 当然如果是在块中使用，当你完成文件操作后，文件会在 <code>ifstream</code> 对象的析构函数中自动关闭。</p>
</li>
</ol>
<p>完整示例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main() &#123;
    std::ifstream file(&quot;filename.txt&quot;);
    if (!file.is_open()) &#123;
        std::cerr &lt;&lt; &quot;Failed to open the file.&quot; &lt;&lt; std::endl;
        return 1;
    &#125;

    std::string line;
    while (std::getline(file, line)) &#123;
        std::cout &lt;&lt; line &lt;&lt; std::endl;
    &#125;

    file.close();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="字节读取"><a href="#字节读取" class="headerlink" title="字节读取"></a>字节读取</h4><p>在 C++ 中，如果想按字节（或二进制模式）读取文件，可以使用 <code>&lt;fstream&gt;</code> 库的 <code>ifstream</code> 类，并在打开文件时指定 <code>std::ios::binary</code> 标志。按字节读取文件通常用于处理二进制文件，如图像、音频或其他非文本文件。</p>
<ol>
<li><p><strong>以二进制模式打开文件</strong></p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::ifstream file(&quot;filename.bin&quot;, std::ios::binary);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p><strong>检查文件是否成功打开</strong></p>
<p> 检查操作和字符读取一样，使用<code>is_open()</code>方法</p>
</li>
<li><p><strong>按字节读取文件</strong></p>
<p> 读取字节操作主要分为：<strong>读取单个字节</strong>、<strong>读取多个字节</strong>：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> byte<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>byte<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>byte<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Process the byte</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> byte<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 定义一个可以存储1024字节的数组,作为读取缓冲区</span>
<span class="token keyword">const</span> size_t bufferSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>  
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>bufferSize<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 一次读取多个字节到一个缓冲区中</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> file<span class="token punctuation">.</span><span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 处理缓冲区中的每个字节</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 两者都是使用的 <code>read</code>方法，接受两个参数。第一个为 读取存放字符or字符串，第二个为 需要读取的大小。此外该函数还具有判断读取是否为空的效果。</p>
<p> 当你从文件中一次读取多个字节，你通常使用一个缓冲区。缓冲区是一个数组或容器，用于临时存储从文件中读取的数据。使用缓冲区的好处是，与一次读取一个字节相比，它可以更高效地读取大量数据，因为文件操作（特别是磁盘访问）通常比内存操作要慢得多。</p>
<p> 注意：<code>read</code> 方法可能不会填满整个缓冲区，特别是当文件的末尾接近时。你可以使用 <code>gcount</code> 方法来确定实际已经读取了多少字节。一旦数据被读入缓冲区，你可以遍历缓冲区并处理每个字节。例如，打印每个字节：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> file<span class="token punctuation">.</span><span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

</li>
</ol>
<h3 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h3><h4 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h4><p>C++中主要使用<code>std::ofstream</code>做文本字符输出。<code>std::ofstream</code> 是 C++ 标准库中的一个类，用于写入文件。它是 <code>std::ostream</code> 的一个特化，专门用于文件输出。以下是关于 <code>std::ofstream</code> 的详细介绍：</p>
<ol>
<li><p>打开已有文件、创建文件</p>
<p> 使用 <code>std::ofstream</code>，你可以创建一个新文件或写入现有文件。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>ofstream <span class="token function">file</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    file <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, File!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>ofstream接受第二个参数，用来指定模式，它拥有多种模式：</p>
<ul>
<li><code>std::ios::out</code>: 输出模式，默认模式。</li>
<li><code>std::ios::app</code>: 追加模式，写操作从文件末尾开始。</li>
<li><code>std::ios::ate</code>: 打开文件并移动到文件末尾。</li>
<li><code>std::ios::trunc</code>: 如果文件已存在，则先截断文件。</li>
<li><code>std::ios::binary</code>: 二进制模式。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 以追加模式打开文件</span>
std<span class="token double-colon punctuation">::</span>ofstream <span class="token function">file</span><span class="token punctuation">(</span><span class="token string">"output.txt"</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ios<span class="token double-colon punctuation">::</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="2">
<li><p>写入操作</p>
<p> 使用插入操作符 <code>&lt;&lt;</code> 将数据写入文件，就像使用 <code>std::cout</code> 一样。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
file <span class="token operator">&lt;&lt;</span> <span class="token string">"Age: "</span> <span class="token operator">&lt;&lt;</span> age <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p> 对于二进制文件的输出，使用write方法。它允许你直接写入原始字节，而不进行任何格式化或转换。</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ostream&amp; write(const char* buffer, std::streamsize count);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 参数：</p>
<ul>
<li><code>buffer</code>: 一个指向要写入数据的字符数组的指针。</li>
<li><code>count</code>: 要写入的字节数。</li>
</ul>
<p> 假设你有一个简单的数据结构，并且你想将其写入一个二进制文件:</p>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Data &#123;
    int id;
    double value;
&#125;;

int main() &#123;
    Data data &#x3D; &#123;123, 456.789&#125;;

    std::ofstream file(&quot;data.bin&quot;, std::ios::binary);
    file.write(reinterpret_cast&lt;const char*&gt;(&amp;data), sizeof(data));
    file.close();

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 注意：使用 <code>reinterpret_cast</code> 将 需要保存的数据结构的指针转换为 <code>const char*</code>，以满足 <code>write()</code> 方法的参数要求。</p>
<p> 将程序的数据外置保存为文件，这种操作叫做序列化操作。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>其他有用的方法</strong>:</p>
<ul>
<li><p><code>tellp()</code>: 返回当前的写位置。</p>
</li>
<li><p><code>seekp(pos)</code>: 将写位置移动到指定的位置。</p>
</li>
<li><p><code>flush()</code>: 刷新缓冲区，确保所有数据都被写入文件。</p>
<p>  通常写入文件只有在文件对象被关闭后才会被保存。但当希望确保数据立即被写入磁盘时，可以使用 <code>flush()</code>。但在不需要立即写入数据的情况下，过度使用它可能会导致性能问题，因为刷新操作可能相对较慢。</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;fstream&gt;

int main() &#123;
    std::ofstream file(&quot;output.txt&quot;);
    file &lt;&lt; &quot;Writing some data...&quot;;
    file.flush();  &#x2F;&#x2F; 确保文件写入立即完成
    &#x2F;&#x2F; ... more code ...
    file.close();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  当然其实常用的<code>std::endl</code>换行操作，不仅仅是一个换行符。当你将 <code>std::endl</code> 写入一个输出流时，它也会调用 <code>flush()</code>。</p>
<p>  但要注意，频繁地使用 <code>std::endl</code> 可能会导致性能下降，因为每次都会触发缓冲区的刷新。如果不需要立即刷新缓冲区，只需要简单的换行操作，在输出文本使用 <code>&#39;\n&#39;</code> 通常是更好的选择。</p>
</li>
</ul>
</li>
<li><p><strong>错误处理</strong></p>
<p> 文件写出不一定总是顺利，使用 <code>fail()</code>, <code>bad()</code>, 和 <code>good()</code> 方法可以检查流的状态。例如，如果写操作失败，<code>fail()</code> 会返回 <code>true</code>。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Handle write error</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="复制操作"><a href="#复制操作" class="headerlink" title="复制操作"></a>复制操作</h3><p>复制操作，简而言之，就是 打开旧文件，读取数据，关闭旧文件，创建新文件，写入数据，关闭新文件。</p>
<p>以下是使用 C++ 复制文件的简单代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span>

<span class="token keyword">bool</span> <span class="token function">copyFile</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> sourcePath<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> destPath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 通过二进制模式打开 旧文件</span>
    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">source</span><span class="token punctuation">(</span>sourcePath<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ios<span class="token double-colon punctuation">::</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过二进制模式创建 新文件</span>
    std<span class="token double-colon punctuation">::</span>ofstream <span class="token function">dest</span><span class="token punctuation">(</span>destPath<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ios<span class="token double-colon punctuation">::</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>source<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>dest<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 文件打开失败</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 使用缓冲区按块复制文件</span>
    <span class="token keyword">const</span> size_t bufferSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>  <span class="token comment">// 例如，1024字节 , 1KB</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>bufferSize<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> bufferSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        dest<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> source<span class="token punctuation">.</span><span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 处理最后一个不完整的块（如果有的话）</span>
    dest<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> source<span class="token punctuation">.</span><span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    source<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dest<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyFile</span><span class="token punctuation">(</span><span class="token string">"source.txt"</span><span class="token punctuation">,</span> <span class="token string">"destination.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"File copied successfully!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Error copying file."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>说明</strong>:</p>
<ul>
<li><strong>二进制模式</strong>: 在打开文件时，我们使用了 <code>std::ios::binary</code> 标志。这确保文件以二进制模式进行读写，这对于非文本文件（如图像或可执行文件）尤为重要。即使是文本文件，使用二进制模式也是一个好主意，因为它可以确保文件的内容不会被修改（例如，换行符的转换）。</li>
<li><strong>按块复制</strong>: 使用缓冲区按块读取和写入文件比逐字节复制更高效。这是因为文件操作（特别是磁盘访问）通常比内存操作要慢得多。</li>
<li><strong>错误处理</strong>: 在实际应用中，你可能需要更详细的错误处理，例如检查文件是否存在、是否有足够的磁盘空间等。上述示例提供了基本的错误处理，但在生产环境中可能需要更多的细节。</li>
</ul>
<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><p>序列化是一个过程，其中数据结构或对象的状态被转换为一个可以存储或传输的格式。序列化后的数据可以随后被重新构建（或反序列化）为原始数据结构或对象。序列化常用于以下场景：</p>
<ul>
<li>数据持久性：将对象保存到文件或数据库中。</li>
<li>远程过程调用：例如，在网络上发送对象。</li>
<li>分布式计算：将数据发送到另一个进程或机器进行处理。</li>
<li>深拷贝：创建对象的完整副本。</li>
</ul>
<p>在 C++ 中，没有内置的序列化机制，但有多种方法可以实现序列化：</p>
<ol>
<li><strong>手动序列化</strong>: 你可以为每个类或数据结构编写自己的序列化和反序列化函数。这通常涉及利用IO流将每个成员变量转换为字节流，并在反序列化时执行相反的操作。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Data &#123;
    int id;
    std::string name;

    &#x2F;&#x2F; 序列化操作,将数据输出为外置文件.
    void serialize(std::ofstream&amp; os) const &#123;
        os.write(reinterpret_cast&lt;const char*&gt;(&amp;id), sizeof(id));
        size_t length &#x3D; name.size();
        os.write(reinterpret_cast&lt;const char*&gt;(&amp;length), sizeof(length));
        os.write(name.c_str(), length);
    &#125;

    &#x2F;&#x2F; 反序列化操作,读取外置文件数据为数据.
    void deserialize(std::ifstream&amp; is) &#123;
        is.read(reinterpret_cast&lt;char*&gt;(&amp;id), sizeof(id));
        size_t length;
        is.read(reinterpret_cast&lt;char*&gt;(&amp;length), sizeof(length));
        char* buffer &#x3D; new char[length];
        is.read(buffer, length);
        name.assign(buffer, length);
        delete[] buffer;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><strong>使用库</strong>: 相比于手动序列化操作，使用 第三方C++ 库提供序列化功能，这些库通常更灵活、更安全，并处理许多边缘情况。<ul>
<li><strong>Boost.Serialization</strong>: 这是一个非常强大的库，支持多种数据格式（如二进制、XML 和文本）和复杂的数据结构。</li>
<li><strong>Cereal</strong>: 这是一个现代、轻量级的 C++11 序列化库。</li>
<li><strong>protobuf (Google Protocol Buffers)</strong>: 这是一个高效的序列化库，特别适用于网络通信和数据存储。</li>
</ul>
</li>
<li><strong>注意事项</strong>:<ul>
<li><strong>版本控制</strong>: 如果数据结构在不同的软件版本之间发生变化，你需要确保旧版本的数据可以在新版本的软件中被正确反序列化。</li>
<li><strong>安全性</strong>: 当反序列化来自不受信任的源的数据时，需要特别小心，因为恶意的或损坏的数据可能导致未定义的行为或安全漏洞。</li>
<li><strong>性能</strong>: 序列化和反序列化可能是计算密集型的，特别是对于大型或复杂的数据结构。</li>
</ul>
</li>
</ol>
<h2 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h2><p>C++中引入了一个 左右值 概念。它们描述了对象在内存中的位置和身份。</p>
<p>理解这个概念对于深入了解 C++ 的内存管理和新的 C++11/14/17 中引入的移动语义特别重要。</p>
<p>直接用代码解释：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> 
<span class="token number">12</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">//Error,12本身是编译器中的固定值不能被赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>简单来说 =号 （赋值符）左边的对象即 左值，右边的对象即右值。上述A对象即 左值，12为右值。</p>
<p>左值通常为可赋值的元素，而右值不能被赋值。当然这些只是片面解释。</p>
<h3 id="左值-Lvalue"><a href="#左值-Lvalue" class="headerlink" title="左值 (Lvalue)"></a>左值 (Lvalue)</h3><ol>
<li><strong>定义</strong>：<strong>左值是一个可以定位到存储位置的表达式，是实际存储位置的元素。换句话说，左值有一个可以访问的内存地址。</strong></li>
<li><strong>名称的来源</strong>：<strong>左值的名称来源于它可以出现在赋值操作的左边或右边</strong>（也就是说出现左值 不仅只能在赋值符左边）。</li>
<li><strong>示例</strong>：变量通常是左值，因为它们代表一个具体的内存位置。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 10;  &#x2F;&#x2F; x 是左值
x &#x3D; 20;      &#x2F;&#x2F; x 可以出现在赋值操作的左边<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h3 id="右值-Rvalue"><a href="#右值-Rvalue" class="headerlink" title="右值 (Rvalue)"></a>右值 (Rvalue)</h3><ol>
<li><strong>定义</strong>：<strong>右值是一个不代表存储位置的表达式，因此不能为其分配值。它是一个临时的、无名的值，或者说是一个即将被销毁的值。</strong></li>
<li><strong>名称的来源</strong>：<strong>右值的名称来源于它只能出现在赋值操作的右边。</strong></li>
<li><strong>示例</strong>：字面量、临时对象或返回值都是右值。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token comment">// 13是右值</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// c是实际明确的元素，c是左值</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> c <span class="token operator">+</span> b<span class="token punctuation">;</span>  <span class="token comment">// 赋值的整体是 (c + b),它将作为一个临时值, 即c+b 是右值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>在 C++11 及以后的版本中，为了优化资源管理和提高性能，引入了右值引用和移动语义的概念。</p>
<p>常规的引用都是其<code>左值引用</code>，引用的是存储 在内存中的对象。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 2；
int&amp; b &#x3D; a；  &#x2F;&#x2F; 这是常规的&quot;引用&quot;,也就是&quot;左值引用&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>而右值引用，使用<code>类型&amp;&amp;</code>表示。顾名思义就是 对临时的、未定义的值的引用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int&amp;&amp; rvalueRef &#x3D; 10 + 20;  &#x2F;&#x2F; 10 + 20 是一个右值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面是解释：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void printName(std::string&amp; name)
&#123;
  ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述函数中参数明确了定义了一个string左值引用，它支持接受一个string对象，注意这里没有加上const修饰符。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">:</span>string a <span class="token operator">=</span> <span class="token string">"Zssaer"</span><span class="token punctuation">;</span>
<span class="token function">printName</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面printName接收了一个定义了的string对象a。但如果当我们直接让其接受未定义的一个字符串呢？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">printName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Ryan Kity"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 编译报错。显示printName不接受临时元素。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>为了避开隐式转换的关系，特别使用了string构造函数，但上述操作依然编译报错，表示printName函数无法接受未定义的临时元素。</p>
<p>C++中为了让其函数接受临时元素的右值，有两者方法：</p>
<ol>
<li><p>在接受左值引用参数前加上const修饰符，这是最常见的操作。</p>
<p> 表示该值不能被修改，这种设计决策的背后是一个安全性的考虑：临时值是短暂的，它们在表达式结束后就会被销毁。如果允许非 <code>const</code> 引用绑定到临时值，并在函数内部修改它，那么这可能会导致意外的行为，因为你实际上正在修改一个即将被销毁的值。</p>
<p> 但是这种方式其实会额外触发接受函数的 <code>拷贝构造函数</code>，额外增加程序内存开销，这个问题将会在后面移动语义中出现。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 42 是一个临时值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>使用右值引用。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 42 是一个临时值</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 编译错误,函数不在支持定义了的对象.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 上述函数支持了临时值，但对于定义了的左值便不再支持了。</p>
</li>
</ol>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>移动语义是C++11引入的重要特性之一。它是左右值知识点的重要点，也是难点。</p>
<p>它允许资源从一个对象“移动”到另一个对象，而不是传统的复制。理解它能够有效的优化函数的定义、赋值操作。</p>
<p>下面是一段典型的A包含B 代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class EntityA
&#123;
private:
	std::string name;

public:
	EntityA(const std::string&amp; string)  &#x2F;&#x2F;构造函数
		: name(string)
	&#123;
		printf(&quot;Created!\n&quot;);
	&#125;

	EntityA(const EntityA&amp; other)  &#x2F;&#x2F; 拷贝构造函数
		: name(other.name)
	&#123;
		printf(&quot;Copied!\n&quot;);
	&#125;

	void sayMyName()
	&#123;
		printf(name.c_str());
		printf(&quot;\n&quot;);
	&#125;
&#125;;

class EntityB
&#123;
private:
	EntityA m_a;

public:
	EntityB(const EntityA&amp; a)
		: m_a(a)
	&#123;
	&#125;

	void printName()
	&#123;
		m_a.sayMyName();
	&#125;
&#125;;

int main()
&#123;
	EntityB entity_b(EntityA(&quot;Zssaer&quot;));
	entity_b.printName();
	std::cin.get();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述中 EntityB 类 包含了一个EntityA，EntityA中包含了一个name字符串成员。</p>
<p>我们使用<code>EntityB entity_b(EntityA(&quot;Zssaer&quot;));</code>创建 EntityB对象。最后输出：</p>
<pre class="line-numbers language-none"><code class="language-none">Created!
Copied!
Zssaer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里不仅调用了EntityA本身的构造函数，还调用了拷贝构造函数。相当于整个流程是这样的：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">EntityA entity_a(&quot;Zssaer&quot;);  &#x2F;&#x2F;调用EntityA构造函数
EntityB entity_b();
entity_b.m_a &#x3D; entity_a;  &#x2F;&#x2F;调用EntityA拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>整个流程中，我们临时创建entity_a对象，然后又拷贝赋值到entity_b，相当于白白浪费掉了entity_a对象。</p>
<p>对于合理的节约空间，其实entity_b中m_a 应该直接使用临时创建的entity_a对象，而不是再去复制创建一个新的。</p>
<p>这便是移动语义的存在含义：<strong>移动直接使用右值，而不是拷贝值。</strong></p>
<p>要知道移动代替拷贝，我们需要在EntityA类中创建 <strong>移动构造函数</strong>，它和拷贝构造函数很相似，它的作用是移动临时的右值 构建一个对象。</p>
<p>PS : 移动构造函数就是本身的右值引用函数.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">EntityA(EntityA&amp;&amp; other) noexcept
&#123;
		printf(&quot;Move!\n&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样EntityA类就实现了右值的移动创建。</p>
<p>然后需要在EntityB中实现右值的<strong>移动</strong>创建，因为它们是包含的：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">EntityB(EntityA&amp;&amp; a)
		: m_a((EntityA&amp;&amp;)a)  &#x2F;&#x2F;: m_a(std::move(a))
&#123;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上方初始化中，一定要将其a强行转换（<strong>也可以使用std::move 将其转换为右值引用</strong>）为 右值引用类型，不然依旧会以左值的方式调用拷贝构造函数。因为右值引用在函数体内定义后，就默认变为了左值引用了，在初始化中依然需要再次定义为右值引用，这样才能调用EntityA的移动构造函数。</p>
<p>除此之外，还可以使用std::forward函数模板:</p>
<blockquote>
<p><code>std::forward</code> 是C++标准库中的一个函数模板，通常用于在泛型编程中完美转发（perfect forwarding）参数。完美转发是一种技术，用于将参数以原样传递给另一个函数，包括参数的值类别（lvalue 或 rvalue）。它在C++11引入的右值引用（rvalue reference）和移动语义的背景下变得特别重要。</p>
<p>在C++中，有两种主要的值类别：左值（lvalue）和右值（rvalue）。</p>
<ul>
<li>左值（lvalue）通常是可以取地址的表达式，如变量名或具有名称的表达式。</li>
<li>右值（rvalue）通常是临时值或不具有名称的表达式。</li>
</ul>
<p><code>std::forward</code> 的主要目的是确保将参数以正确的值类别传递给其他函数，以避免不必要的拷贝或移动操作。它通常在函数模板中与引用折叠和转发引用一起使用，以保持参数的原始值类别。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">EntityB</span><span class="token punctuation">(</span>EntityA<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">m_a</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>EntityA<span class="token operator">></span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//: m_a(std::move(a))</span>
<span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>这样便将其临时创建的EntityA对象直接以Move的方式，而不是Copy方式，定义到了EntityB中的m_a中了。</p>
<p><strong>总结：简而言之，移动语义就是将其临时的右值直接应用到 左值中，而不是再额外Copy。 主要的操作方式是使用 移动构造函数。</strong></p>
<p>移动语义的主要优势是性能提升。例如，当你返回一个大型 <code>std::vector</code> 或 <code>std::string</code> 时，使用移动语义可以避免不必要的数据复制。此外，它还使得某些资源管理模式，如独占所有权模式，变得更加简单和高效。</p>
<h3 id="三法则、五法则"><a href="#三法则、五法则" class="headerlink" title="三法则、五法则"></a>三法则、五法则</h3><p>如果类定义了 拷贝构造函数（copy ctor）、拷贝赋值运算符（copy operator=）或析构函数（dtor），通常也需要考虑合理定义其他两个，这被称为 **”Rule of Three/三法则”**。</p>
<p>在 C++11 及以后，这个规则扩展到五个，包括移动构造函数（move ctor）和移动赋值运算符（move operator=），称为**”Rule of Five/五法则”**。</p>
<p>如果在没有特殊需求情况下，往往直接delete掉其他like “copy ctor”、“operator=”操作。这时良好的且优秀的C++代码的体现。</p>
<h2 id="优雅地处理函数返回错误"><a href="#优雅地处理函数返回错误" class="headerlink" title="优雅地处理函数返回错误"></a>优雅地处理函数返回错误</h2><p>C++中使用异常处理非常繁琐，在项目中通常以返回错误码来提示错误。</p>
<p>下面是优雅地返回错误解决方法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Policy</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Fn</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">></span> <span class="token comment">// requires...</span>
<span class="token keyword">constexpr</span> I <span class="token function">exec_on</span><span class="token punctuation">(</span>Policy <span class="token keyword">const</span> <span class="token operator">&amp;</span>p<span class="token punctuation">,</span> I code<span class="token punctuation">,</span> Fn <span class="token operator">&amp;&amp;</span>f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token comment">// noexcept(...)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Fn<span class="token operator">></span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">></span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> code<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// to be impl</span>
<span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// to be impl</span>
<span class="token keyword">int</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// to be impl</span>

<span class="token keyword">void</span> <span class="token function">error_report</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 错误码处理函数</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> cond_nonminus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> v <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">exec_on</span><span class="token punctuation">(</span>cond_nonminus<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret2 <span class="token operator">=</span> <span class="token function">exec_on</span><span class="token punctuation">(</span>cond_nonminus<span class="token punctuation">,</span> ret1<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret3 <span class="token operator">=</span> <span class="token function">exec_on</span><span class="token punctuation">(</span>cond_nonminus<span class="token punctuation">,</span> ret2<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret3 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">error_report</span><span class="token punctuation">(</span>ret3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</div>

      <!-- Post Comments -->
      
    <!-- 使用 changyan -->
<div id="changyan-comment">
    <!--PC和WAP自适应版-->
<div id="SOHUCS" sid="2023/09/16/CPP-Lean2/"  ></div>
<script type="text/javascript">
(function(){
var appid = 'cyvzq2tmJ';
var conf = 'e61bcf9ca7baef66559e7e33e21fe290';
var width = window.innerWidth || document.documentElement.clientWidth;
if (width < 960) {
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

</div>
<style>
    #changyan-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>

    </div>
    <!-- Copyright 版权 start -->
    <div id="copyright">
  <ul>
    <li>
      &copy;Powered By
      <a target="_blank" rel="noopener" href="https://hexo.io/" style="border-bottom: none">hexo</a>
    </li>
    <li>Author: <a style="border-bottom: none">@Zssaer</a></li>
  </ul>
  <ul>
    <li>
      <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" id="beian">蜀ICP备2021031070号</a>
    </li>
  </ul>
  
  <span id="busuanzi_container_site_pv"> 2024 </span>
  
</div>

  </div>
  <script>
    const originalTitle = document.title;
    document.title = `C++学习笔记（下）` + `|` + originalTitle;
  </script>
</body>



 	
</html>
