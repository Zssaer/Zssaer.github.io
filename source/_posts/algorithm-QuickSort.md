---
    title:  算法与数据结构(三)-快速排序详解 # 文章标题  
    date:  2022/03/01 17:26:34  # 文章发表时间
    tags:
    - Algorithm
    categories: 算法 # 分类
    thumbnail: https://img.zssaer.cn/wallhaven-q2m9z7.jpg?x-oss-process=style/wallpaper # 略缩图
---
# **算法与数据结构(三)-快速排序详解**

## 前言
在[算法与数据结构(二) - 数组](https://zssaer.cn/2022/02/25/algorithm2/)中我们简绍了快速排序算法，其中快速排序部分描述为《算法四》中的，理解起来有点难度。本篇文章专门用来分析其快速排序的具体过程。

## 解析步骤

快速排序详细操作分为三步骤：

1. 寻找 基准元素。通常我们使用其**快排里，我们只要记住把头部元素当作基准元素就够了（假设数组元素是随机分布的）**

2. 使用左右双指针来进行扫描，左边指针向右扫描，右边指针向左扫描。

   ![](https://img.zssaer.cn/1060770-20171122233213305-812504424.png)

   (图源来自《啊哈，算法》)

   这里我们选取首位6 来作为基准元素。

   这时候，左右游标开始分别向右/左移动，它们遵循的规则分别是：

   - **左游标**向**右**扫描， **跨过所有小于基准元素的数组元素**, 直到遇到一个**大于或等于基准元素**的数组元素， 在那个位置**停下**。
   - **右游标**向**左**扫描， **跨过所有大于基准元素的数组元素,** 直到遇到一个**小于或等于基准元素**的数组元素，在那个位置**停下**。

3. 当左右指针扫描都结束时，两个指针停下的地方如果**未相交**的话，那么就交换两指针下的元素。

   ![](https://img.zssaer.cn/1060770-20171122233230696-1718795911.png)

   交换之后，会发现两指针又会实现其条件，所以继续执行第二步扫描操作，反复循环。

4. 最终两指针会相交（至于是左指针还是右指针最后移动，这个取决于谁先开始，但和这结果、性能无关）,从而停下。

   ![](https://img.zssaer.cn/1060770-20171122233307336-208181132.png)

   这时，会发现，数组大致 状态是 ： 基准元素（中间值）+小于中间值的数组+大于中间值的数组。

   所以这时我们需要**将其相交的元素与其基准元素 交换**，这样就是 小于中间值的数组+基准元素（中间值）+大于中间值的数组。

   ![](https://img.zssaer.cn/1060770-20171122233327399-371718013.png)

5. 对小于中间值的数组，和大于中间值的数组分别 再次执行 1-4步骤。也就是再循环多次操作对两边数组。使用递归即可。

   这样的话小于中间值的数组和大于中间值的数组就会被反复排序正常。

## 代码实现

下面使用Java代码表示整个过程：

```java
private static void sort(int[] a, int low, int high) {
    // 终止递归
    if (high <= low) {
        return;
    }
    // 调用partition进行切分
    int j = partition(a, low, high);
    // 对上一轮排序(切分)时，基准元素左边的子数组进行递归
    sort(a, low, j - 1);
    // 对上一轮排序(切分)时，基准元素右边的子数组进行递归
    sort(a, j + 1, high);
}

/**
 * 数组切分
 * 将数组按照基准元素分为两部分
 * @return 最终基准元素位置
 */
private static int partition(int[] a, int low, int high) {
    // i, j为左右扫描指针 PS： 思考下为什么j比i 多加一个1呢？
    int i = low, j = high + 1;
    // pivotkey 为选取的基准元素（头元素）
    int pivotkey = a[low];

    while (true) {
        // 右游标左移
        while (a[--j] > pivotkey) {
            if (j == low) {
                break;
            }
        }
        // 左游标右移
        while (a[++i] < pivotkey) {
            if (i == high) {
                break;
            }
        }
        // 左右游标相遇时候停止， 所以跳出外部while循环
        if (i >= j) {
            break;
        }
        // 左右游标都中途停止时,互相交换元素
        exchange(a, i, j);
    }
    // 基准元素和游标相遇时所指元素交换，为最后一次交换
    exchange(a, low, j);
    // 一趟排序完成， 返回基准元素位置
    return j;
}

/**
 * 交换两个数组元素
 */
private static void exchange(int[] a, int i, int j) {
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```



