<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.png"/>
	<link rel="shortcut icon" href="/img/favicon.png">
	<meta name="baidu-site-verification" content="code-KLcpk3wnwR" />
	
			<title>趙天一ლ(ﾟдﾟლ)You know、You don’t know</title>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, user-scalable=no"
/>
<link rel="stylesheet" href="/css/mic_main.css" />
<link rel="stylesheet" href="/css/dropdownMenu.css" />
<!-- <script src="/js/live2d/autoload.js"></script> -->

<meta name="keywords" content="Zssaer JavaWeb TIANYI ZHAO" />

<noscript>
  <link rel="stylesheet" href="/css/noscript.css" />
</noscript>
<style type="text/css">
  /* body{
    background: url('https://zssaer.oss-cn-chengdu.aliyuncs.com/wallhaven-r7r551.jpg?x-oss-process=style/wallpaper') center 0 no-repeat;
    content: " ";
    position: fixed;
  } */
  body:before {
    content: " ";
    position: fixed;
    top: 0;
    background: url('https://zssaer.oss-cn-chengdu.aliyuncs.com/wallhaven-r7r551.jpg?x-oss-process=style/wallpaper') center 0 no-repeat;

    right: 0;
    bottom: 0;
    left: 0;
    background-size: cover;
  }
</style>

			    

    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.scrollex.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.scrolly.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/skel.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/util.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		<!-- Layouts -->


<!--  代码渲染  -->
<script src="/js/prism.js"></script>
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body
  class=""
  data-prismjs-copy="复制"
  data-prismjs-copy-error="请按Ctrl+C手动复制"
  data-prismjs-copy-success="复制成功!"
>
  <div class="mask-border"></div>
  <!-- Wrapper 外包 s-->
  <div id="wrapper" class="fade-in">
    <!-- Intro 头部显示 s -->
    <!-- Intro 头部显示 e -->
    <!-- Header 头部logo start -->
    <header id="header">
    <a href="/" class="logo">Refrain</a>
</header>
    <!-- Nav 导航条 start -->
    <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">Categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/JAVA/">JAVA</a></li><li><a class="category-link" href="/categories/Python/">Python</a></li><li><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li><a class="category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="AboutMe">
		                AboutMe
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="Wallpaper">
		                Wallpaper
		            </a>
		        </li>
		        
		        <li>
		            <a href="/bangumis/" title="Bangumis">
		                Bangumis
		            </a>
		        </li>
		        
						<li class="active">
							<a href="#s1">Other</a>
											<ul class="submenu">
													<li>
													<a class="category-link" href="/another/billiard.html">台球模拟V1.0</a>
												</li>
											</ul>
						</li>

            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Zssaer" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="git" href="https://gitee.com/Zssaer01" target="_blank" rel="noopener">
                            <i class="icon fa fa-git"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>
    <aside id="toc_menu"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"> Docker入门教程(一)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.0.4.</span> <span class="toc-text">对比传统虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.5.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">镜像与容器关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Registry-%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">Docker Registry&#x2F;仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.</span> <span class="toc-text">Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">查询本地镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">运行本地镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">删除本地镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commit%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">commit定制镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">Dockerfile定制镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.</span> <span class="toc-text">Docker容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">启动容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">终止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">容器后台运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">进入容器内部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.5.</span> <span class="toc-text">导出和导入容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.6.</span> <span class="toc-text">删除容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.8.</span> <span class="toc-text">Docker仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Hub"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">Docker Hub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">私有仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.8.2.1.</span> <span class="toc-text">启动仓库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.8.2.2.</span> <span class="toc-text">上传镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F-1"><span class="toc-number">1.0.8.2.3.</span> <span class="toc-text">获取镜像</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">修改默认仓库地址</span></a></li></ol></li></ol></li></ol></li></ol></aside>
    <div id="main">
      
      <div
        class="post_page_title_img"
        style="
          height: 25rem;
          background-image: url(https://zssaer.oss-cn-chengdu.aliyuncs.com/dockerlogo.jpg?x-oss-process=style/wallpaper);
          background-position: center;
          background-repeat: no-repeat;
          background-size: cover;
          -moz-background-size: cover;
          overflow: hidden;
        "
      >
        <a href="#" style="padding: 4rem 4rem 2rem 4rem"
          ><h2 id="page-title">Docker入门教程(一)</h2></a
        >
      </div>
      
      <button id="toc_button" onclick="openTocSidebar()">文章导航</button>
      <!-- <div id="content_toc">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"> Docker入门教程(一)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.0.4.</span> <span class="toc-text">对比传统虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.5.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">镜像与容器关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Registry-%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">Docker Registry&#x2F;仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.</span> <span class="toc-text">Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">查询本地镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">运行本地镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">删除本地镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commit%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">commit定制镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">Dockerfile定制镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.</span> <span class="toc-text">Docker容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">启动容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">终止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">容器后台运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">进入容器内部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.5.</span> <span class="toc-text">导出和导入容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.7.6.</span> <span class="toc-text">删除容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.8.</span> <span class="toc-text">Docker仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Hub"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">Docker Hub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">私有仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BB%93%E5%BA%93"><span class="toc-number">1.0.8.2.1.</span> <span class="toc-text">启动仓库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F"><span class="toc-number">1.0.8.2.2.</span> <span class="toc-text">上传镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F-1"><span class="toc-number">1.0.8.2.3.</span> <span class="toc-text">获取镜像</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">修改默认仓库地址</span></a></li></ol></li></ol></li></ol></li></ol>
            </div>     -->

      <!-- Post -->
      <div class="typo" style="padding: 3rem"><h1 align = "center"> Docker入门教程(一)</h1>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。</p>
<p>发布一项项目就需要在服务器上进行各种相关环境配置，非常繁琐，而且极易出现兼容错误（“这段代码在我机器上没问题啊”）等，甚至导致项目发布延期，就算单个项目可能顺利了，但如果项目做集群的话，那么就会非常困难。</p>
<p>这时人们就在想，如果有一个容器直接配置好所有运行环境，就想系统ISO文件一样，使用克隆应用直接克隆不就轻松了吗？</p>
<p>所以这时Docker就诞生了，Docker采用的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/docker.jpg"></p>
<p><strong>Docker</strong> 最初是 <code>dotCloud</code> 公司创始人 <a target="_blank" rel="noopener" href="https://github.com/shykes">Solomon Hykes</a>在法国期间发起的一个公司内部项目，它是基于 <code>dotCloud</code> 公司多年云服务技术的一次革新，并于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Docker_(software)">2013 年 3 月以 Apache 2.0 授权协议开源 </a>，主要项目代码在 <a target="_blank" rel="noopener" href="https://github.com/moby/moby">GitHub</a>上进行维护。<code>Docker</code> 项目后来还加入了 Linux 基金会，并成立推动 <a target="_blank" rel="noopener" href="https://opencontainers.org/">开放容器联盟（OCI）</a>。</p>
<p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a target="_blank" rel="noopener" href="https://github.com/moby/moby">GitHub 项目 </a>已经超过 5 万 7 千个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，<a target="_blank" rel="noopener" href="https://www.docker.com/blog/dotcloud-is-becoming-docker-inc/">dotCloud 公司决定改名为 Docker </a>。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p>
<p>Docker由Google推出的Go语言开发。对进程进行封装隔离，属于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术 </a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p>
<p>Docker拥有Linux端、Mac端、Windows端，但主要以Linux端为主，因为正常工作环境下，服务器也是在Linux搭建的，所以推荐使用Linux搭建Docker。</p>
<p>当然也可以在实际搭建前进行体验练习Docker，<a target="_blank" rel="noopener" href="https://labs.play-with-docker.com/">Play with Docker</a>这个网站支持在线网络上进行体验Docker,每次申请体验有时间限制,但过时候可以继续申请,完全免费。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>更高效的利用系统资源</strong></li>
</ul>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<ul>
<li><strong>更快速的启动时间</strong></li>
</ul>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<ul>
<li><strong>一致的运行环境</strong></li>
</ul>
<p><code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p>
<ul>
<li><strong>持续交付和部署</strong></li>
</ul>
<p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/image/dockerfile/">Dockerfile</a> 来进行镜像构建，并结合 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a>系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment)</a>系统进行自动部署。</p>
<p>而且使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/image/build.html"><code>Dockerfile</code></a> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<h3 id="对比传统虚拟机"><a href="#对比传统虚拟机" class="headerlink" title="对比传统虚拟机"></a>对比传统虚拟机</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">容器</th>
<th align="left">虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动</td>
<td align="left">秒级</td>
<td align="left">分钟级</td>
</tr>
<tr>
<td align="left">硬盘使用</td>
<td align="left">一般为 <code>MB</code></td>
<td align="left">一般为 <code>GB</code></td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">接近原生</td>
<td align="left">弱于</td>
</tr>
<tr>
<td align="left">系统支持量</td>
<td align="left">单机支持上千个容器</td>
<td align="left">一般几十个</td>
</tr>
</tbody></table>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>Docker</strong> 包括三个基本概念</p>
<ul>
<li><strong>镜像</strong>（<code>Image</code>）</li>
<li><strong>容器</strong>（<code>Container</code>）</li>
<li><strong>仓库</strong>（<code>Repository</code>）</li>
</ul>
<img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/docker.png" style="zoom:110%;" />

<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>或许都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于<code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如Docker官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong><br>镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。说的通俗点，Docker就是使用了分层存储技术的软件压缩包。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器的实质是进程，但与直接在外部执行的进程不同，容器进程运行于属于自己的独立的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间 (opens new window)</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</p>
<p>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于系统的虚拟机下操作一样。</p>
<p>这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，所以很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器<strong>删除</strong>而丢失。按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。</p>
<p>所以所有的文件写入操作，都应该使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/data_management/volume.html">数据卷（Volume）</a>、或者 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/data_management/bind-mounts.html">绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<h4 id="镜像与容器关系"><a href="#镜像与容器关系" class="headerlink" title="镜像与容器关系"></a>镜像与容器关系</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<h4 id="Docker-Registry-仓库"><a href="#Docker-Registry-仓库" class="headerlink" title="Docker Registry/仓库"></a>Docker Registry/仓库</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/repository/registry.html">Docker Registry</a> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<p>Docker Registry 拥有一个公开服务，它开放给用户使用、允许用户管理镜像的 Registry 服务，允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。就类似于Maven和NPM这些架包管理器一样。</p>
<p>Docker默认的Registry 公开服务使用的是 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>除此以外，还有 Red Hat 的 <a target="_blank" rel="noopener" href="https://quay.io/repository/">Quay.io </a>；Google的 <a target="_blank" rel="noopener" href="https://cloud.google.com/container-registry/">Google Container Registry </a>，<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes </a>的镜像使用的就是这个服务；当然代码托管平台 <a target="_blank" rel="noopener" href="https://github.com/">GitHub </a>也推出了 <a target="_blank" rel="noopener" href="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io </a>。</p>
<p>由于某些活蟹原因，在国内访问这些服务可能会比较慢。国内有Docker下载加速器，常见的有 <a target="_blank" rel="noopener" href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器 </a>、<a target="_blank" rel="noopener" href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud 加速器 </a>等。</p>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。</p>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>可以前往<a target="_blank" rel="noopener" href="https://hub.docker.com/search?q=&type=image">Docker Hub</a>上获取官方高质量的镜像。</p>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<h4 id="查询本地镜像"><a href="#查询本地镜像" class="headerlink" title="查询本地镜像"></a>查询本地镜像</h4><p>从远程仓库获取镜像下载成功后，可以使用<code>docker images ls</code>查看当前已拥有的镜像。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker image <span class="token function">ls</span>
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
redis                latest              5f515359c7f8        <span class="token number">5</span> days ago          <span class="token number">183</span> MB
nginx                latest              05a60462f8ba        <span class="token number">5</span> days ago          <span class="token number">181</span> MB
mongo                <span class="token number">3.2</span>                 fe9198c04d62        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
<span class="token operator">&lt;</span>none<span class="token operator">></span>               <span class="token operator">&lt;</span>none<span class="token operator">></span>              00285df0df87        <span class="token number">5</span> days ago          <span class="token number">342</span> MB
ubuntu               <span class="token number">18.04</span>               329ed837d508        <span class="token number">3</span> days ago          <span class="token number">63</span>.3MB
ubuntu               bionic              329ed837d508        <span class="token number">3</span> days ago          <span class="token number">63</span>.3MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们其实对应的是同一个镜像。</p>
<p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。我们把它叫做悬浮镜像。这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>，代表着这个镜像已经过时了，所以也可以随意删除它。</p>
<h4 id="运行本地镜像"><a href="#运行本地镜像" class="headerlink" title="运行本地镜像"></a>运行本地镜像</h4><p>有了镜像后，我们就能够以这个镜像为<strong>基础启动并运行一个容器</strong>。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code>终端 并且进行交互式操作的话，使用<code>docker run</code>命令:</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker run -it --rm -p <span class="token number">80</span>:80 --name ubuntu-test ubuntu:18.04 <span class="token function">bash</span>

root@e7009c6ce357:/<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>docker run</code>命令参数:</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端,两个参数可以合二为一。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>-p</code>：定义端口，前为本地主机端口，后为容器端口。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>--name</code>：定义启动后的容器名称。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
<li><code>-d</code>:后台运行,不会堵塞shell终端.</li>
</ul>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker port fa <span class="token number">80</span>
<span class="token number">0.0</span>.0.0:32768<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像<span class="token operator"><span class="token file-descriptor important">1</span>></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像<span class="token operator"><span class="token file-descriptor important">2</span>></span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>(id前几位数字)、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<p>可以 用 docker image ls 命令来配合删除多个镜像。比如删除所有的redis镜像：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker image <span class="token function">ls</span> -q redis<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h4 id="commit定制镜像"><a href="#commit定制镜像" class="headerlink" title="commit定制镜像"></a>commit定制镜像</h4><p>当我们修改好容器中的文件后，也就是改动了容器的存储层。可以通过 <code>docker diff</code> 命令看到具体的改动。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">diff</span> webserver
C /root
A /root/.bash_history
C /run
C /usr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>容器中任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为新的镜像。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$docker</span> commit <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>容器ID或容器名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>仓库名<span class="token operator">></span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>标签<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用方法例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker commit --author <span class="token string">"Tao Wang &lt;twang2218@gmail.com>"</span> <span class="token punctuation">\</span>
    --message <span class="token string">"修改了默认网页"</span> webserver nginx:v2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>将其当前webserver容器打包为<code>nginx:v2</code>镜像，其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p>
<p>是不是觉得这样工作环境下就使用commit进行打包成镜像就行了？</p>
<p>虽然使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<p>因为使用commit打包安装软件包、编译构建，会有大量的无关内容被添加进来，将会导致镜像极为臃肿。此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，这种黑箱镜像的维护工作是非常痛苦的。</p>
<p>所以定制镜像应该使用 <code>Dockerfile</code> 来完成，而不是使用<code>docker commit</code>。但<code>docker commit</code> 命令除了学习之外，其实还有一些特殊的应用场合，比如被入侵后保存现场等。</p>
<h4 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h4><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>以Nginx为例:</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">mkdir</span> mynginx
$ <span class="token builtin class-name">cd</span> mynginx
$ <span class="token function">touch</span> Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>编辑里面内容为:</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginx
RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>FROM 指定基础镜像</li>
<li>RUN 用来执行命令行命令,由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。RUN命令可以叠加,建议使用<code>&amp;&amp;</code>叠加,执行就和手工建立镜像的过程一样。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</li>
</ul>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM debian:stretch

RUN set -x; buildDeps&#x3D;&#39;gcc libc6-dev make wget&#39; \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot; \
    &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \
    &amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1 \
    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \
    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \
    &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。</p>
<p>Dockerfile中的本地主机地址都是使用相对地址,而内部容器定义使用的是绝对地址。</p>
<p>定制完Dockerfile文件后,在其文件目录下的执行<code>docker build</code>命令:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker build -t nginx:v3 <span class="token builtin class-name">.</span>
Sending build context to Docker daemon <span class="token number">2.048</span> kB
Step <span class="token number">1</span> <span class="token builtin class-name">:</span> FROM nginx
 ---<span class="token operator">></span> e43d811ce2f4
Step <span class="token number">2</span> <span class="token builtin class-name">:</span> RUN <span class="token builtin class-name">echo</span> <span class="token string">'&lt;h1>Hello, Docker!&lt;/h1>'</span> <span class="token operator">></span> /usr/share/nginx/html/index.html
 ---<span class="token operator">></span> Running <span class="token keyword">in</span> 9cdc27646c7b
 ---<span class="token operator">></span> 44aa4490ce2c
Removing intermediate container 9cdc27646c7b
Successfully built 44aa4490ce2c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。最终生成了<code>nginx:v3</code>镜像。</p>
<p><strong>注意：</strong></p>
<p>我们会看到 <code>docker build</code> 命令最后有一个 <code>.</code>，<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。</p>
<p><strong>其它 <code>docker build</code> 的用法</strong></p>
<p><code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># $env:DOCKER_BUILDKIT=0</span>
<span class="token comment"># export DOCKER_BUILDKIT=0</span>

$ docker build -t hello-world https://github.com/docker-library/hello-world.git<span class="token comment">#master:amd64/hello-world</span>

Step <span class="token number">1</span>/3 <span class="token builtin class-name">:</span> FROM scratch
 ---<span class="token operator">></span>
Step <span class="token number">2</span>/3 <span class="token builtin class-name">:</span> COPY hello /
 ---<span class="token operator">></span> ac779757d46e
Step <span class="token number">3</span>/3 <span class="token builtin class-name">:</span> CMD <span class="token punctuation">[</span><span class="token string">"/hello"</span><span class="token punctuation">]</span>
 ---<span class="token operator">></span> Running <span class="token keyword">in</span> d2a513a760ed
Removing intermediate container d2a513a760ed
 ---<span class="token operator">></span> 038ad4142d2b
Successfully built 038ad4142d2b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这行命令指定了构建所需的 Git repo，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。]</p>
<h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<ul>
<li><p>新建并启动：在第一次获取到的镜像时，启动为镜像。使用<code>docker run </code> 命令。已经在运行本地镜像中说明，所以略过。</p>
</li>
<li><p>启动已终止容器：可以利用 <code>docker container start</code> 命令，直接将一个已经终止运行（<code>exited</code>）的容器重新启动运行。可以利用<code>docker ps</code>命令查看容器状态。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
</li>
</ul>
<h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。</p>
<h4 id="容器后台运行"><a href="#容器后台运行" class="headerlink" title="容器后台运行"></a>容器后台运行</h4><p>正常使用<code>docker run</code>时，运行容器会直接进入容器内容的终端中。</p>
<p>而更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这时会返回容器ID,并且继续保持主机的Shell终端中,而不会进入容器内,从而避免堵塞。</p>
<p>容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注意：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<h4 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h4><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令</p>
<ul>
<li><p><code>docker attach</code> 命令：<code>docker attach + 容器ID/容器名称</code> 如果用这种方法从这个 容器 中 exit，会导致容器的停止。</p>
</li>
<li><p><code>docker exec</code>命令:<code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ docker run -dit ubuntu
69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6

$ docker container <span class="token function">ls</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
69d137adef7a        ubuntu:latest       <span class="token string">"/bin/bash"</span>         <span class="token number">18</span> seconds ago      Up <span class="token number">17</span> seconds                           zealous_swirles

$ docker <span class="token builtin class-name">exec</span> -i 69d1 <span class="token function">bash</span>
<span class="token function">ls</span>
bin
boot
dev
<span class="token punctuation">..</span>.

$ docker <span class="token builtin class-name">exec</span> -it 69d1 <span class="token function">bash</span>
root@69d137adef7a:/<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个操作在容器中使用exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
</li>
</ul>
<h4 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h4><p>如果要导出本地某个容器为tar压缩包，可以使用 <code>docker export</code> 命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container <span class="token function">ls</span> -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
7691a814370e        ubuntu:18.04        <span class="token string">"/bin/bash"</span>         <span class="token number">36</span> hours ago        Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">21</span> hours ago                       <span class="token builtin class-name">test</span>
$ docker <span class="token builtin class-name">export</span> 7691a814370e <span class="token operator">></span> ubuntu.tar
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果要将某个容器tar压缩包导入到docker镜像的话，可以使用 <code>docker import</code> 命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> ubuntu.tar <span class="token operator">|</span> docker <span class="token function">import</span> - test/ubuntu:v1.0
$ docker image <span class="token function">ls</span>
REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
test/ubuntu         v1.0                9d37a6082e97        About a minute ago   <span class="token number">171.3</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>此外，也可以通过指定 URL 或者某个目录来导入，例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">import</span> http://example.com/exampleimage.tgz example/imagerepo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container <span class="token function">rm</span> trusting_newton
trusting_newton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>仓库（<code>Repository</code>）是集中存放镜像的地方。类似于Maven中的lib仓库。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<p>但大部分时候，并不需要严格区分这两者的概念。</p>
<h4 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h4><p>Docker默认公开服务使用的远程仓库为<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。</p>
<p>大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>使用它这前需要在上面注册一个Docker账号。可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。你可以通过 <code>docker logout</code> 退出登录。</p>
<p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker search centos
NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
centos                             The official build of CentOS.                   <span class="token number">6449</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
ansible/centos7-ansible            Ansible on Centos7                              <span class="token number">132</span>                  <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
consol/centos-xfce-vnc             Centos container with <span class="token string">"headless"</span> VNC session…   <span class="token number">126</span>                  <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   <span class="token number">117</span>                  <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>
centos/systemd                     systemd enabled base container.                 <span class="token number">96</span>                   <span class="token punctuation">[</span>OK<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然更推荐前往网站上进行搜索,然后直接获取pull地址.</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/dockerhub.png"></p>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker tag ubuntu:18.04 username/ubuntu:18.04

$ docker image <span class="token function">ls</span>

REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE
ubuntu                                                   <span class="token number">18.04</span>                  275d79972a86        <span class="token number">6</span> days ago          <span class="token number">94</span>.6MB
username/ubuntu                                          <span class="token number">18.04</span>                  275d79972a86        <span class="token number">6</span> days ago          <span class="token number">94</span>.6MB

$ docker push username/ubuntu:18.04

$ docker search username

NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
username/ubuntu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面命令中的 <code>username</code> 请替换为你的 Docker 账号用户名即可。</p>
<h4 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h4><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/registry/"><code>docker-registry</code> </a>是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a target="_blank" rel="noopener" href="https://github.com/docker/distribution"><code>docker-registry</code></a>v2.x 版本。</p>
<h5 id="启动仓库"><a href="#启动仓库" class="headerlink" title="启动仓库"></a>启动仓库</h5><p>使用官方 <code>registry</code> 镜像来运行docker-registry。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -d -p <span class="token number">5000</span>:5000 --restart<span class="token operator">=</span>always --name registry registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。</p>
<p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -d <span class="token punctuation">\</span>
    -p <span class="token number">5000</span>:5000 <span class="token punctuation">\</span>
    -v /opt/data/registry:/var/lib/registry <span class="token punctuation">\</span>
    registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h5><p>创建好私有仓库之后，上传这前为了防止混淆镜像名称,可以先使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。</p>
<p>例如,使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker tag ubuntu:latest <span class="token number">127.0</span>.0.1:5000/ubuntu:latest
$ docker image <span class="token function">ls</span>
REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                            latest              ba5877dc9bec        <span class="token number">6</span> weeks ago         <span class="token number">192.7</span> MB
<span class="token number">127.0</span>.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        <span class="token number">6</span> weeks ago         <span class="token number">192.7</span> MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p>
<p>使用 <code>docker push</code> 上传标记的镜像。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker push <span class="token number">127.0</span>.0.1:5000/ubuntu:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>用 <code>curl</code> 命令查看仓库中的镜像。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> <span class="token number">127.0</span>.0.1:5000/v2/_catalog
<span class="token punctuation">&#123;</span><span class="token string">"repositories"</span>:<span class="token punctuation">[</span><span class="token string">"ubuntu"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="获取镜像-1"><a href="#获取镜像-1" class="headerlink" title="获取镜像"></a>获取镜像</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull <span class="token number">127.0</span>.0.1:5000/ubuntu:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="修改默认仓库地址"><a href="#修改默认仓库地址" class="headerlink" title="修改默认仓库地址"></a>修改默认仓库地址</h4><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<p>对于使用 <code>systemd</code> (Ubuntu 16.04+, Debian 8+, centos 7)的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
  <span class="token property">"registry-mirror"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>
    <span class="token string">"https://mirror.baidubce.com"</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"insecure-registries"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"192.168.199.100:5000"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p>
<p><strong>作者:Zssaer 转载请著名。</strong></p>
</div>

      <!-- Post Comments -->
      
    <!-- 使用 changyan -->
<div id="changyan-comment">
    <!--PC和WAP自适应版-->
<div id="SOHUCS" sid="2021/08/09/docker/"  ></div>
<script type="text/javascript">
(function(){
var appid = 'cyvzq2tmJ';
var conf = 'e61bcf9ca7baef66559e7e33e21fe290';
var width = window.innerWidth || document.documentElement.clientWidth;
if (width < 960) {
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

</div>
<style>
    #changyan-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>

    </div>
    <!-- Copyright 版权 start -->
    <div id="copyright">
  <ul>
    <li>
      &copy;Powered By
      <a target="_blank" rel="noopener" href="https://hexo.io/" style="border-bottom: none">hexo</a>
    </li>
    <li>Author: <a style="border-bottom: none">@Zssaer</a></li>
  </ul>
  <ul>
    <li>
      <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" id="beian">蜀ICP备2021031070号</a>
    </li>
  </ul>
  
  <span id="busuanzi_container_site_pv"> 2024 </span>
  
</div>

  </div>
  <script>
    const originalTitle = document.title;
    document.title = `Docker入门教程(一)` + `|` + originalTitle;
  </script>
</body>



 	
</html>
