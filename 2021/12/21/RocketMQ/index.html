<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.png"/>
	<link rel="shortcut icon" href="/img/favicon.png">
	<meta name="baidu-site-verification" content="code-KLcpk3wnwR" />
	
			<title>趙天一ლ(ﾟдﾟლ)You know、You don’t know</title>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, user-scalable=no"
/>
<link rel="stylesheet" href="/css/mic_main.css" />
<link rel="stylesheet" href="/css/dropdownMenu.css" />
<!-- <script src="/js/live2d/autoload.js"></script> -->

<meta name="keywords" content="Zssaer JavaWeb TIANYI ZHAO" />

<noscript>
  <link rel="stylesheet" href="/css/noscript.css" />
</noscript>
<style type="text/css">
  /* body{
    background: url('https://zssaer.oss-cn-chengdu.aliyuncs.com/wallhaven-r7r551.jpg?x-oss-process=style/wallpaper') center 0 no-repeat;
    content: " ";
    position: fixed;
  } */
  body:before {
    content: " ";
    position: fixed;
    top: 0;
    background: url('https://zssaer.oss-cn-chengdu.aliyuncs.com/wallhaven-r7r551.jpg?x-oss-process=style/wallpaper') center 0 no-repeat;

    right: 0;
    bottom: 0;
    left: 0;
    background-size: cover;
  }
</style>

			    

    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.scrollex.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/jquery.scrolly.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/skel.min.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/util.js"></script>
    <script src="https://zssaer.oss-cn-chengdu.aliyuncs.com/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		<!-- Layouts -->


<!--  代码渲染  -->
<script src="/js/prism.js"></script>
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body
  class=""
  data-prismjs-copy="复制"
  data-prismjs-copy-error="请按Ctrl+C手动复制"
  data-prismjs-copy-success="复制成功!"
>
  <div class="mask-border"></div>
  <!-- Wrapper 外包 s-->
  <div id="wrapper" class="fade-in">
    <!-- Intro 头部显示 s -->
    <!-- Intro 头部显示 e -->
    <!-- Header 头部logo start -->
    <header id="header">
    <a href="/" class="logo">Refrain</a>
</header>
    <!-- Nav 导航条 start -->
    <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">Categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/JAVA/">JAVA</a></li><li><a class="category-link" href="/categories/Python/">Python</a></li><li><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li><a class="category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="AboutMe">
		                AboutMe
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="Wallpaper">
		                Wallpaper
		            </a>
		        </li>
		        
		        <li>
		            <a href="/bangumis/" title="Bangumis">
		                Bangumis
		            </a>
		        </li>
		        
						<li class="active">
							<a href="#s1">Other</a>
											<ul class="submenu">
													<li>
													<a class="category-link" href="/another/billiard.html">台球模拟V1.0</a>
												</li>
											</ul>
						</li>

            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Zssaer" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="git" href="https://gitee.com/Zssaer01" target="_blank" rel="noopener">
                            <i class="icon fa fa-git"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>
    <aside id="toc_menu"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E6%95%99%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">RocketMQ教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">关于消息队列优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E8%80%A6%E6%96%B9%E9%9D%A2"><span class="toc-number">1.2.1.</span> <span class="toc-text">解耦方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%97%E6%97%B6%E6%96%B9%E9%9D%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">耗时方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8A%E5%B3%B0%E6%96%B9%E9%9D%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">削峰方面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">关于消息队列缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%A0%B8%E5%BF%83%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.</span> <span class="toc-text">RocketMQ核心以及概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">RocketMQ搭建使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.1.</span> <span class="toc-text">搭建操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDRocketMQ"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">下载RocketMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2NameServer%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">部署NameServer服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2Broker%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">部署Broker服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%ADRocketMQ%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">关闭RocketMQ服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%90%AD%E5%BB%BA"><span class="toc-number">1.5.3.</span> <span class="toc-text">控制台搭建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.</span> <span class="toc-text">RocketMQ操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.1.</span> <span class="toc-text">验证功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">启动消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">启动生产者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">项目中使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5Maven%E4%BE%9D%E8%B5%96"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">导入Maven依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">生产者发送端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.2.1.</span> <span class="toc-text">发送信息操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">消费者端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text">接受消费消息操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E8%B4%B9"><span class="toc-number">1.6.3.</span> <span class="toc-text">事务消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E8%B4%B9%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.4.</span> <span class="toc-text">事务消费的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">关于消费者组</span></a></li></ol></li></ol></li></ol></aside>
    <div id="main">
      
      <div
        class="post_page_title_img"
        style="
          height: 25rem;
          background-image: url(https://zssaer.oss-cn-chengdu.aliyuncs.com/marek-piwnicki-JNiYQHi5Hjc-unsplash.jpg?x-oss-process=style/wallpaper);
          background-position: center;
          background-repeat: no-repeat;
          background-size: cover;
          -moz-background-size: cover;
          overflow: hidden;
        "
      >
        <a href="#" style="padding: 4rem 4rem 2rem 4rem"
          ><h2 id="page-title">RocketMQ教程</h2></a
        >
      </div>
      
      <button id="toc_button" onclick="openTocSidebar()">文章导航</button>
      <!-- <div id="content_toc">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E6%95%99%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">RocketMQ教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">关于消息队列优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E8%80%A6%E6%96%B9%E9%9D%A2"><span class="toc-number">1.2.1.</span> <span class="toc-text">解耦方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%97%E6%97%B6%E6%96%B9%E9%9D%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">耗时方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8A%E5%B3%B0%E6%96%B9%E9%9D%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">削峰方面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">关于消息队列缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%A0%B8%E5%BF%83%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.</span> <span class="toc-text">RocketMQ核心以及概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">RocketMQ搭建使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.1.</span> <span class="toc-text">搭建操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDRocketMQ"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">下载RocketMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2NameServer%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">部署NameServer服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2Broker%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">部署Broker服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%ADRocketMQ%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">关闭RocketMQ服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%90%AD%E5%BB%BA"><span class="toc-number">1.5.3.</span> <span class="toc-text">控制台搭建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.</span> <span class="toc-text">RocketMQ操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.1.</span> <span class="toc-text">验证功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">启动消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">启动生产者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">项目中使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5Maven%E4%BE%9D%E8%B5%96"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">导入Maven依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">生产者发送端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.2.1.</span> <span class="toc-text">发送信息操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">消费者端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text">接受消费消息操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E8%B4%B9"><span class="toc-number">1.6.3.</span> <span class="toc-text">事务消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E8%B4%B9%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.4.</span> <span class="toc-text">事务消费的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">关于消费者组</span></a></li></ol></li></ol></li></ol>
            </div>     -->

      <!-- Post -->
      <div class="typo" style="padding: 3rem"><h1 id="RocketMQ教程"><a href="#RocketMQ教程" class="headerlink" title="RocketMQ教程"></a>RocketMQ教程</h1><p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/image-20211221175531854.png" alt="image-20211221175531854"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>RocketMQ 是阿里巴巴开源的分布式消息中间件。目前已经成为Apache中的开源基金会项目。它的同类产品有RabbitMQ、Kafka、ActiveMQ。</p>
<p>RocketMQ 支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。它里面有几个区别于标准消息中件间的概念，如<code>Group、Topic、Queue</code>等。系统组成则由<code>Producer、Consumer、Broker、NameServer</code>等。</p>
<p><strong>为什么选择RocketMQ?</strong></p>
<ul>
<li>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式等特点</li>
<li>Producer、Consumer、队列都可以分布式</li>
<li>Producer 向一些队列轮流发送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 Consumer 实例消费这个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费这个 Topic 对应的队列集合</li>
<li>能够保证严格的消息顺序</li>
<li>支持拉（pull）和推（push）两种消息模式</li>
<li>高效的订阅者水平扩展能力</li>
<li>实时的消息订阅机制</li>
<li>亿级消息堆积能力</li>
<li>支持多种消息协议，如 JMS、OpenMessaging 等</li>
<li>较少的依赖</li>
</ul>
<h2 id="关于消息队列优点"><a href="#关于消息队列优点" class="headerlink" title="关于消息队列优点"></a>关于消息队列优点</h2><p>在项目中为什么要使用消息队列?</p>
<p>目前大部分项目中都有三种应用处理: </p>
<p>解耦（耦合性指的就是个模块之间的关联程度。耦合性越低模块的独立性越强）、耗时方面、削峰方面（通过技术手段减少峰值访问的压力）</p>
<p>当然还有其他的，这里就不做过多说明了。</p>
<h3 id="解耦方面"><a href="#解耦方面" class="headerlink" title="解耦方面"></a>解耦方面</h3><p><strong>传统模式设计:</strong></p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/o_jieou5.png"></p>
<p>很明显，传统模式设计下，系统间耦合性太强（耦合性指的就是个模块之间的关联程度。耦合性越低模块的独立性越强），如上图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！当然不可否认的是，目前绝大部分中小项目都是这种设计，因为它设计简单易懂省事。</p>
<p><strong>中间件模式:</strong></p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/o_jieou6.png"></p>
<p>使用中间件模式，将系统BCD的要求通过消息形式写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改，这种设计显然更加先进。</p>
<h3 id="耗时方面"><a href="#耗时方面" class="headerlink" title="耗时方面"></a>耗时方面</h3><p><strong>传统模式设计:</strong></p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/o_yibu2.png"></p>
<p>使用传统模式设计，一些非必要的业务逻辑以同步的方式运行，太耗费时间。</p>
<p><strong>中间件模式:</strong></p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/o_yibu3.png"></p>
<p>使用中间件模式，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。</p>
<h3 id="削峰方面"><a href="#削峰方面" class="headerlink" title="削峰方面"></a>削峰方面</h3><p><strong>传统模式设计:</strong></p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/o_xuefeng1.png"></p>
<p>使用传统模式设计，并发量大的时候，所有的请求直接一个一个怼到数据库，造成数据库连接异常。</p>
<p><strong>中间件模式:</strong></p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/o_xuefeng2.png"></p>
<p>使用中间件模式，系统A慢慢的按照数据库能处理的并发量，通过用户传来的消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p>
<h2 id="关于消息队列缺点"><a href="#关于消息队列缺点" class="headerlink" title="关于消息队列缺点"></a>关于消息队列缺点</h2><p>上面讲述了使用消息队列的优点好处。当然作为好东西，不可能完全完美，那自然也会存在缺点。</p>
<p>一个使用了消息队列 的项目，如果连具体问题都没有考虑过，就把把消息队列组件引进去了，那就给自己的项目带来了风险。我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。要记住，不要给公司挖坑，当然面对要随时要跑路的黑心公司除外！</p>
<p>除了这个以外，还要考虑很多系统处理方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，引入信息队列会让项目系统复杂性直线增加。</p>
<h2 id="RocketMQ核心以及概念"><a href="#RocketMQ核心以及概念" class="headerlink" title="RocketMQ核心以及概念"></a>RocketMQ核心以及概念</h2><p>讲了这么多消息队列的方面内容，那么回归正题RocketMQ，说说RocketMQ的核心概率。</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/285763-20190821175219196-1211062486.png"></p>
<p>RocketMQ 在任何一个环境都是可扩展的，<strong>生产者（Producer）必须是一个集群，消息服务器（Name Server）必须是一个集群，消费者（Consumer）也同样。</strong></p>
<p><strong>集群级别的高可用，是消息队列 RocketMQ 跟其他的消息服务器的主要区别</strong>。</p>
<p>消息生产者发送一条消息到消息服务器，消息服务器会随机的选择一个消费者，只要这个消费者消费成功就认为是成功了。</p>
<p><strong>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。</strong></p>
<blockquote>
<p>Producer ：负责生产消息，一般由业务系统负责生产消息，简单形象点来说就是 买票时创建买票的订单。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，而单向发送不需要。</p>
<p>Broker ：消息中转角色，负责存储消息、转发消息，简单形象点来说就是 存储用户创建买票的订单的仓库。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<p>Consumer ：负责消费消息，一般是后台系统负责异步消费，简单形象点来说就是 从买票的订单仓库后台处理订单进行买票。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<p>Topic：表示一类消息的集合，简单形象点来说就是将同类买票的订单归为一个集合。每个Topic（主题）包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
</blockquote>
<p>除了这些以外，还有Name Server，即代理服务器。</p>
<blockquote>
<p>Name Server：名称服务充当路由消息的提供者，简单形象点来说 就是类似于服务注册服务器。生产者或消费者能够通过名字服务查找定位各Topic（主题）相应的Broker IP列表。多个Name server实例组成集群，但相互独立，没有信息交换。</p>
</blockquote>
<p>上面差不多就是其RocketMQ全部的关键部分组成简绍了。</p>
<p>总体来说 整个使用RocketMQ的流程就是： </p>
<p><em><strong>Consumer生成消息 -》 Consumer通过NameServer归类到对应Topic -》Topic存储在Broker中 -》Consumer 通过NameServer调取到对应Topic 所在的Broker -》Consumer 依次消费消息</strong></em></p>
<h2 id="RocketMQ搭建使用"><a href="#RocketMQ搭建使用" class="headerlink" title="RocketMQ搭建使用"></a>RocketMQ搭建使用</h2><p>要记住RocketMQ是由集群模式下进行的，在实际生成环境下是分布式模式搭建的，而不是单机搭建。</p>
<p>在安装RocketMQ之前我们先来理解Group概念，在RocketMQ中Group是很重要的。通过Group机制，让RocketMQ天然的支持消息负载均衡！比如某个Topic有9条消息，其中一个Consumer Group有3个实例（3个进程 OR 3台机器），那么每个实例将均摊3条消息！（注意RocketMQ只有一种模式，即发布订阅模式。）如下图所示：</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/285763-20190813181031834-879282107.png"></p>
<p>与众多集群一样它的模式类似于Mysql的主从机制。</p>
<ul>
<li>单Master模式：无需多言，一旦单个broker重启或宕机，一切都结束了！很显然，线上不可以使用。</li>
<li>多Master模式：全是Master，没有Slave。当然，一个broker宕机了，应用是无影响的，缺点在于宕机的Master上未被消费的消息在Master没有恢复之前不可以订阅。</li>
<li>多Master多Slave模式（异步复制）：多对Master-Slave，高可用！采用异步复制的方式，主备之间短暂延迟，MS级别。Master宕机，消费者可以从Slave上进行消费，不受影响，但是Master的宕机，会导致丢失掉极少量的消息。</li>
<li>多Master多Slave模式（同步双写）：和上面的区别点在于采用的是同步方式，也就是在Master/Slave都写成功的前提下，向应用返回成功，可见不论是数据，还是服务都没有单点，都非常可靠！缺点在于同步的性能比异步稍低。</li>
</ul>
<h3 id="搭建操作"><a href="#搭建操作" class="headerlink" title="搭建操作"></a>搭建操作</h3><p>我们将要搭建一个简易的RocketMQ集群，它包含1个nameserver，两个master（Broker服务器）。至于Producer和Consumer服务器集群则普通的集群服务，这里不做简绍。</p>
<h4 id="下载RocketMQ"><a href="#下载RocketMQ" class="headerlink" title="下载RocketMQ"></a>下载RocketMQ</h4><p>首先我们下载RocketMQ官方版本：</p>
<p>下载官方二进制二进制压缩包：<a target="_blank" rel="noopener" href="https://dlcdn.apache.org/rocketmq/4.9.2/rocketmq-all-4.9.2-bin-release.zip"><strong>https://dlcdn.apache.org/rocketmq/4.9.2/rocketmq-all-4.9.2-bin-release.zip</strong></a> ，然后解压。</p>
<h4 id="部署NameServer服务器"><a href="#部署NameServer服务器" class="headerlink" title="部署NameServer服务器"></a>部署NameServer服务器</h4><p>由于RocketMQ由JAVA语言编辑而来，务必确保安装JAVA，并且正确配置JAVA环境。</p>
<p>–Windows操作：–</p>
<p>由于其默认JAVA配置大小为默认2G，对于我们来说明显大了，所以我们需要先修改内存使用大小,用编辑器修改一下<code>runserver.cmd</code>脚本：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rem <span class="token builtin class-name">set</span> <span class="token string">"JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span>
<span class="token builtin class-name">set</span> <span class="token string">"JAVA_OPT=%JAVA_OPT% -server -Xms256m -Xmx512m"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用Windows进行部署前，需要将其RocketMQ文件夹配置到系统变量下。</p>
<p>​    变量名：ROCKETMQ_HOME</p>
<p>​    变量值：MQ解压路径\MQ文件夹名</p>
<p>然后启动Cmd命令框执行进入至‘MQ文件夹\bin’下，然后执行‘start mqnamesrv.cmd’，启动NAMESERVER。成功后会弹出提示框，此框勿关闭。</p>
<p>– Linux操作：–</p>
<p>先使用Vim进行编辑MQ文件夹下的/bin/runserver.sh 文件，因为Name Server 默认配置Xmx=4G ，对于小型Linux服务器来说应该进行修改。这里我们修改为1GB。</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vi &#x2F;bin&#x2F;runserver.sh

JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125;-server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;320m&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>修改后：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;320m&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>后台启动NameServer，并动态查看启动状态：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nohup sh bin&#x2F;mqnamesrv -n &quot;150.205.110.91:9876&quot; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;

tail -f ~&#x2F;logs&#x2F;rocketmqlogs&#x2F;namesrv.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里的的 启动时 -n 后为启动IP即端口，对于本地的话，可以使用127.0.0.1。</p>
<h4 id="部署Broker服务器"><a href="#部署Broker服务器" class="headerlink" title="部署Broker服务器"></a>部署Broker服务器</h4><p>由于RocketMQ由JAVA语言编辑而来，务必确保安装JAVA，并且正确配置JAVA环境。</p>
<p>配置RocketMQ的Broker服务器需要设置其Broker配置文件，用来进行确定其Broker配置。我们需要2台Broker服务器，所以我们需要准备2个Broker配置文件。</p>
<p>好在我们下载的二进制RocketMQ中的Conf文件夹中有一系列的测试配置，我们直接使用其 <code>2m-noslave</code>文件夹下的<code>broker-a.properties</code>和<code>broker-b.properties</code>配置即可。</p>
<p>–Windos操作：–</p>
<p>与NameServer一样,我们需要修改它的默认内存使用大小，使用编辑器修改runbroker.cmd文件:</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">rem set &quot;JAVA_OPT&#x3D;%JAVA_OPT% -server -Xms2g -Xmx2g&quot;
set &quot;JAVA_OPT&#x3D;%JAVA_OPT% -server -Xms256m -Xmx512m&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>然后 Cmd命令框执行进入至‘MQ文件夹\bin’下，然后执行‘start mqbroker.cmd -n 127.0.0.1:9876 -c ../conf/2m-noslave/broker-a.properties’，启动BROKER-A。</p>
<p>要在同一台电脑上进行学习的话，我们需要修改下另一个Broker服务器配置，新增额外内容：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#存储路径</span>
<span class="token attr-name">storePathRootDir</span><span class="token punctuation">=</span><span class="token attr-value">~/logs/rocketmqstore</span>
<span class="token comment">#commitLog 存储路径</span>
<span class="token attr-name">storePathCommitLog</span><span class="token punctuation">=</span><span class="token attr-value">~/logs/rocketmqstore/commitlog</span>
<span class="token comment">#消费队列存储路径存储路径</span>
<span class="token attr-name">storePathConsumeQueue</span><span class="token punctuation">=</span><span class="token attr-value">~/logs/rocketmqstore/consumequeue</span>
<span class="token comment">#消息索引存储路径</span>
<span class="token attr-name">storePathIndex</span><span class="token punctuation">=</span><span class="token attr-value">~/logs/rocketmqstore/index</span>
<span class="token comment">#checkpoint 文件存储路径</span>
<span class="token attr-name">storeCheckpoint</span><span class="token punctuation">=</span><span class="token attr-value">~/logs/rocketmqstore/checkpoint</span>
<span class="token comment">#abort 文件存储路径</span>
<span class="token attr-name">abortFile</span><span class="token punctuation">=</span><span class="token attr-value">~/logs/rocketmqstore/abort</span>
<span class="token comment">#端口设置</span>
<span class="token attr-name">listenPort</span><span class="token punctuation">=</span><span class="token attr-value">10950</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为RocketMQ中自带的配置文件时用于多台主机的集群搭建的，所以自然不会将其存储路径固定，端口也都是默认的10911。在单机下进行搭建必须要进行修改，否则启动会报出<code>RocketMq Lock failed,MQ already started</code>错误，表明端口 以及路径被占用。</p>
<p>然后再执行‘start mqbroker.cmd -n 127.0.0.1:9876 -c ../conf/2m-noslave/broker-b.properties’，启动BROKER-B。</p>
<p>–Linux操作：–</p>
<p>与NameServer一样，它的默认JAVA配置Xmx= 8G，我们需要进行修改：</p>
<p>调整java opt：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vi &#x2F;bin&#x2F;runbroker.sh

JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125;-server -Xms8g -Xmx8g -Xmn4g&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>调整后：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms2g -Xmx2g -Xmn1g&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>后台启动：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nohup sh bin&#x2F;mqbroker -n 10.200.110.91:9876 -c .&#x2F;conf&#x2F;2m-noslave&#x2F;broker-a.properties &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在另外一台服务器上 再启动一个Broker服务器：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nohup sh bin&#x2F;mqbroker -n 10.200.110.91:9876 -c .&#x2F;conf&#x2F;2m-noslave&#x2F;broker-b.properties &amp; tail -f ~&#x2F;logs&#x2F;rocketmqlogs&#x2F;broker.log-n ip:9876<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意其中两个配置文件中brokerName不同。所以在自定义配置Broker配置时，brokerName不能相同。</p>
<h3 id="关闭RocketMQ服务"><a href="#关闭RocketMQ服务" class="headerlink" title="关闭RocketMQ服务"></a>关闭RocketMQ服务</h3><p>对于Windos来说关闭服务很简单，ctrl+C即可，当然也可以使用mqshutdown.cmd + broker/namesrv 方式来进行关闭。</p>
<p>对于Linux的话，使用其bin下内置的mqshutdown来进行关闭。</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&gt; sh bin&#x2F;mqshutdown broker
The mqbroker(36695) is running...
Send shutdown request to mqbroker(36695) OK

&gt; sh bin&#x2F;mqshutdown namesrv
The mqnamesrv(36664) is running...
Send shutdown request to mqnamesrv(36664) OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="控制台搭建"><a href="#控制台搭建" class="headerlink" title="控制台搭建"></a>控制台搭建</h3><p>RocketMQ和其他分布式队列组件一样，也有自己的控制台产品，那就是Rocket-console，它是用RocketMQ社区来进行在Github维护的。</p>
<p>目前Rocket-console已经被重命名为**<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq-dashboard">rocketmq-dashboard</a>**。</p>
<p>我们需要克隆一个Rocketmq-dashboard项目到本地来进行部署：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clone https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;rocketmq-dashboard.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>克隆后，我们进入项目文件下的src\main\resources’文件夹，打开‘application.properties’进行相关配置。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">...
<span class="token comment"># 绑定控制台的地址以及端口</span>
<span class="token attr-name">server.address</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1</span>
<span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8083</span>
...
<span class="token comment"># 配置NameServer地址</span>
<span class="token attr-name">rocketmq.config.namesrvAddr</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1:9876</span>
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 不管是在Windos下还是Linux下，使用Maven进行打包然后运行：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mvn clean package -Dmaven.test.skip&#x3D;true
java -jar rocketmq-console-ng-1.0.0.jar &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当然如果在Windos界面下也可以直接在一些IDE直接启动即可。</p>
<p>启动成功后在浏览器中输入配置中的访问地址，即可加入RocketMQ控制台。</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/image-20211221175612800.png" alt="image-20211221175612800"></p>
<p>点击 集群 ,我们也可以轻松看见当前的Broker服务器状态:</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/image-20211221175621335.png" alt="image-20211221175621335"></p>
<h2 id="RocketMQ操作"><a href="#RocketMQ操作" class="headerlink" title="RocketMQ操作"></a>RocketMQ操作</h2><p>下面介绍RocketMQ关键操作</p>
<h3 id="验证功能"><a href="#验证功能" class="headerlink" title="验证功能"></a>验证功能</h3><p>RocketMQ自带了恬送与接收消息的脚本<code>tools.cmd</code>，它用来验证RocketMQ的功能是否正常。</p>
<p><code>tool.cmd</code>脚本需要带参数执行，无法用简单的双击方式启动。因此，我们打开一个cmd窗口，并跳转到bin目录下。</p>
<h4 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h4><p>与<code>mqbroker.cmd</code>脚本类似，启动<code>tool.cmd</code>命令之前我们要指定NameServer地址。</p>
<p>这里我们采用命令方式指定，并启动消费者。我们需要将其sh或者cmd进入其RocketMQ下的bin文件夹中,依次执行如下命令：</p>
<pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">set NAMESRV_ADDR&#x3D;localhost:9876
tools.cmd org.apache.rocketmq.example.quickstart.Consumer
# Linux下使用tools.sh
tools.sh org.apache.rocketmq.example.quickstart.Consumer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中<code>org.apache.rocketmq.example.quickstart.Consumer</code>是RocketMQ下的一个测试 消费者类，就是用来进行测试学习使用的。</p>
<h4 id="启动生产者"><a href="#启动生产者" class="headerlink" title="启动生产者"></a>启动生产者</h4><p>操作同上类似。</p>
<pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">set NAMESRV_ADDR&#x3D;localhost:9876
tools.cmd org.apache.rocketmq.example.quickstart.Producer
# Linux下使用tools.sh
tools.sh org.apache.rocketmq.example.quickstart.Producer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行成功后，生产者会发送1000个消息，然后自动退出。</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/7632473-581d29f7eb055cb9.webp"></p>
<p>此时，在消费者界面按下<code>Ctrl + C</code>，就会收到刚刚生产者发出的消息。</p>
<p><img src="https://zssaer.oss-cn-chengdu.aliyuncs.com/7632473-56e329cea742e9f7.webp"></p>
<p>我们也看通过RocketMQ控制台看见其消费情况。</p>
<p>到这儿，RocketMQ最小应用己经可以正常工作，能满足我们开发环境下调试代码的需求。</p>
<h3 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h3><p>上面验证功能只是在学习和测试中进行使用，作为开发者，需要在其项目中集成RocketMQ组件功能，实现其信息队列功能的话，需要在项目中进行实现消费者、生产者。</p>
<h4 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.rocketmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>rocketmq-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="生产者发送端"><a href="#生产者发送端" class="headerlink" title="生产者发送端"></a>生产者发送端</h4><p>作为生产者端 ，需要配置以下内容在SpringBoot配置中：</p>
<pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">spring
  rocketmq
	# 绑定name Server服务器地址
    name-server: localhost:9876
	# 定义生产者发布 组名
    producer
      group: my-group1
	# 定义要发送的信息的主题集合
	topic: string-topic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="发送信息操作"><a href="#发送信息操作" class="headerlink" title="发送信息操作"></a>发送信息操作</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">RocketMQTemplate</span> rocketMQTemplate<span class="token punctuation">;</span>
<span class="token comment">// 注入定义的主题-topci</span>
<span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"spring.rocketmq.topic"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> topic<span class="token punctuation">;</span>

<span class="token comment">/**
 * 发送简单的MQ消息
 * @param msg
 * @return
 */</span>
<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/send"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Results</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">RemotingException</span><span class="token punctuation">,</span> <span class="token class-name">MQClientException</span><span class="token punctuation">,</span> <span class="token class-name">MQBrokerException</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		<span class="token comment">// 如下两种方式等价</span>
        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token string">"Hello, World! I'm from spring message"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 第三个参数为key</span>
        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">syncSend</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"Hello, World! I'm from simple message"</span><span class="token punctuation">,</span> <span class="token string">"18122811143034568830"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// topic: ORDER，tag: paid, cacel</span>
		rocketMQTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	    <span class="token comment">// 消息体为自定义对象</span>
        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">OrderPaidEvent</span><span class="token punctuation">(</span><span class="token string">"T_001"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"88.00"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


		<span class="token comment">// 发送延迟消息</span>
        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">sendDelayed</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"I'm delayed message"</span><span class="token punctuation">,</span> <span class="token class-name">MessageDelayLevel</span><span class="token punctuation">.</span>TIME_1M<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 发送即发即失消息（不关心发送结果）</span>
		rocketMQTemplate<span class="token punctuation">.</span><span class="token function">sendOneWay</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token string">"I'm one way message"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


		<span class="token comment">// 发送顺序消息</span>
        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">syncSendOrderly</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"I'm order message"</span><span class="token punctuation">,</span> <span class="token string">"1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>RocketMQTemplate是rocketMQ-SpringBoot-starter这个依赖直接封装好了的工具，直接使用它来进行发送、接受等操作。</p>
<h4 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h4><p>作为消费者端 ，需要配置以下内容在SpringBoot配置中：</p>
<pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">spring:
  rocketmq:
    name-server: 127.0.0.1:9876<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="接受消费消息操作"><a href="#接受消费消息操作" class="headerlink" title="接受消费消息操作"></a>接受消费消息操作</h5><p>不同于生产者，使用消费者时，需要随时接受到对应的消息载体，所以需要使用监听器类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@RocketMQMessageListener</span><span class="token punctuation">(</span>topic <span class="token operator">=</span> <span class="token string">"test-topic-1"</span><span class="token punctuation">,</span> consumerGroup <span class="token operator">=</span> <span class="token string">"my-consumer_test-topic-1"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConsumer</span> <span class="token keyword">implements</span> <span class="token class-name">RocketMQListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"received message: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>RocketMQ消费者监听器实现RocketMQListener类，它接受一个泛型，取决于接受的消息载体类型。通过复写onMessage方法来实现其接受消息的功能。</p>
<p>其中@RocketMQMessageListener中主要注解，它定义了对应的topic集合名，用于寻找对应的Broker，来依次获取里面的消息。而consumerGroup则为其消费者的组定义。</p>
<p>除了这样使用，还可以专门定位到某个RocketMQ集群上：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RocketMQMessageListener</span><span class="token punctuation">(</span>nameServer <span class="token operator">=</span> <span class="token string">"127.0.0.1:9877"</span><span class="token punctuation">,</span> instanceName <span class="token operator">=</span> <span class="token string">"tradeCluster"</span><span class="token punctuation">,</span> topic <span class="token operator">=</span> <span class="token string">"test-topic-3"</span><span class="token punctuation">,</span> consumerGroup <span class="token operator">=</span> <span class="token string">"my-consumer_test-topic-3"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以及定义其对应的消费模式和重试次数:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// ConsumeMode为消费模式,ConsumeMode.ORDERLY为按顺序消费</span>
<span class="token comment">// 配置重试次数 reconsumeTimes = -1 代表一直重试</span>
<span class="token annotation punctuation">@RocketMQMessageListener</span><span class="token punctuation">(</span>topic <span class="token operator">=</span> <span class="token string">"test-topic-4"</span><span class="token punctuation">,</span> consumerGroup <span class="token operator">=</span> <span class="token string">"my-consumer_test-topic-6"</span><span class="token punctuation">,</span>
    consumeMode <span class="token operator">=</span> <span class="token class-name">ConsumeMode</span><span class="token punctuation">.</span>ORDERLY<span class="token punctuation">,</span> reconsumeTimes <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>它的所有说明属性如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Consumer 所属消费者分组
 *
 * Consumers of the same role is required to have exactly same subscriptions and consumerGroup to correctly achieve
 * load balance. It's required and needs to be globally unique.
 *
 * See &lt;a href="http://rocketmq.apache.org/docs/core-concept/">here&lt;/a> for further discussion.
 */</span>
<span class="token class-name">String</span> <span class="token function">consumerGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 消费的 Topic
 *
 * Topic name.
 */</span>
<span class="token class-name">String</span> <span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 选择器类型。默认基于 Message 的 Tag 选择。
 *
 * Control how to selector message.
 *
 * @see SelectorType
 */</span>
<span class="token class-name">SelectorType</span> <span class="token function">selectorType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">SelectorType</span><span class="token punctuation">.</span>TAG<span class="token punctuation">;</span>
<span class="token comment">/**
 * 选择器的表达式。
 * 设置为 * 时，表示全部。
 *
 * 如果使用 SelectorType.TAG 类型，则设置消费 Message 的具体 Tag 。
 * 如果使用 SelectorType.SQL92 类型，可见 https://rocketmq.apache.org/rocketmq/filter-messages-by-sql92-in-rocketmq/ 文档
 *
 * Control which message can be select. Grammar please see &#123;@link SelectorType#TAG&#125; and &#123;@link SelectorType#SQL92&#125;
 */</span>
<span class="token class-name">String</span> <span class="token function">selectorExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"*"</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 消费模式。可选择并发消费，还是顺序消费。
 *
 * Control consume mode, you can choice receive message concurrently or orderly.
 */</span>
<span class="token class-name">ConsumeMode</span> <span class="token function">consumeMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">ConsumeMode</span><span class="token punctuation">.</span>CONCURRENTLY<span class="token punctuation">;</span>

<span class="token comment">/**
 * 消息模型。可选择是集群消费，还是广播消费。
 *
 * Control message mode, if you want all subscribers receive message all message, broadcasting is a good choice.
 */</span>
<span class="token class-name">MessageModel</span> <span class="token function">messageModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">MessageModel</span><span class="token punctuation">.</span>CLUSTERING<span class="token punctuation">;</span>

<span class="token comment">/**
 * 消费的线程池的最大线程数
 *
 * Max consumer thread number.
 */</span>
<span class="token keyword">int</span> <span class="token function">consumeThreadMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">64</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 消费单条消息的超时时间
 *
 * Max consumer timeout, default 30s.
 */</span>
<span class="token keyword">long</span> <span class="token function">consumeTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">30000L</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="事务消费"><a href="#事务消费" class="headerlink" title="事务消费"></a>事务消费</h3><p>关于RocketMQ-SpringBoot-Starter默认的消费模式是 按顺序消费，意思就是 “通过消息的发送顺序来进行依次消费处理”，这一种默认的消费模式满足大部分设计要求，但是它对于 一些重要业务来说则显得不足。</p>
<p>一款买票软件，它的买票服务通常逻辑是这样的：订票 -》选择票类型-》生成订单-》支付-》完成购票。</p>
<p>这种涉及到钱的操作一般设计就要十分严谨，如果不使用事务处理的话，当用户订票未付款就会发生订单一直保留，这样不满足原子性（要么同时成功要么全部失败）。</p>
<p>所以我们来使用RocketMQ进行事务消费操作：</p>
<p><strong>生产者：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringTransactionProducer</span> <span class="token punctuation">&#123;</span> 

	<span class="token annotation punctuation">@Autowired</span> 
	<span class="token keyword">private</span> <span class="token class-name">RocketMQTemplate</span> rocketMQTemplate<span class="token punctuation">;</span>
	
	 <span class="token comment">/**
	 * 发送消息 
	 * @param topic  
	 * @param msg 
	 */</span> 
	 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
	 	<span class="token comment">/**
	 	 * 这里的Message不是rocketmq.commen的 
	 	 * 是springframework的接口
	 	 * /
		 Message message = MessageBuilder.withPayload(msg).build(); 
		 
		 /**
		  * myTransactionGroup要和@RocketMQTransactionListener(txProducerGroup = "myTransactionGroup")定义的Group一致 
		  * 消息会通过TransactionGroup找到事务消费者、通过topic普通消费者 只有事务消费者commit 普通消费者的结果才会执行 
		  * /
		 this.rocketMQTemplate.sendMessageInTransaction("myTransactionGroup", topic, message, null); 
		 
		 System.out.println("发送消息成功"); 
	 &#125; 
 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里使用了RocketMQTemplate的sendMessageInTransaction方法进行发送事务消息。</p>
<p>这里它第一个参数需要一个Transaction组参数，用于存放在其业务组下，在消费者中根据TransactionGroup进行额外操作。</p>
<p>我们还要在**生产者(这里是生产者!)**中创建一个RocketMQ业务监听器：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RocketMQTransactionListener</span><span class="token punctuation">(</span>txProducerGroup <span class="token operator">=</span> <span class="token string">"myTransactionGroup"</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">RocketMQLocalTransactionListener</span> <span class="token punctuation">&#123;</span> 

	<span class="token comment">/**
	 * 可以定义一个static final的Map 用来保存返回unknown要回查消息的一些属性 那么所有对象都可以获取该消息回滚前的一些信息
	 * private static Map&lt;String, Object> INFO_MAP = new HashMap&lt;>();
	 */</span>
    
	<span class="token annotation punctuation">@Override</span> 
	<span class="token keyword">public</span> <span class="token class-name">RocketMQLocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
		 <span class="token comment">/**
		   * 该Message是springframework包下的 其获取事务消息的唯一id的方法
		   * String transId = (String)message.getHeaders().get(RocketMQHeaders.TRANSACTION_ID); 
		   * /
		try &#123;
			System.out.println("执行操作1"); 
			Thread.sleep(500); 
			
			System.out.println("执行操作2"); 
			Thread.sleep(800); 
			

	   	    if(...) return LocalTransactionState.COMMIT_MESSAGE

            if(...) return LocalTransactionState.ROLLBACK_MESSAGE

            //如果在检查事务时数据库出现宕机可以让broker过一段时间回查 和return null 效果相同
             if(...) return LocalTransactionState.UNKNOW 

		&#125; catch (Exception e) &#123; 
			e.printStackTrace(); 
			/**
			 * 回滚
			 * 
			 * 可以在该处给 INFO_MAP放一些信息 以便会查时调用
			 * INFO_MAP.put(transId,...);
			 * /
			return RocketMQLocalTransactionState.ROLLBACK;
		&#125;
		
	&#125;

	@Override 
	public RocketMQLocalTransactionState checkLocalTransaction(Message message) &#123; 
		/**
		 * 只去返回commit或者rollback
		 * 
		 * 可以用INFO_MAP取得一些回滚前的信息
		 * String transId = (String)message.getHeaders().get(RocketMQHeaders.TRANSACTION_ID); 
		 * INFO_MAP.get(transId);
		 * /
    &#125; 
&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中RocketMQ业务监听器需要实现RocketMQLocalTransactionListener，其中包含两个重要方法：</p>
<p>executeLocalTransaction：<em>用来执行本地事务</em>，用来执行业务逻辑的地方，返回事务运行状态。</p>
<p>checkLocalTransaction：只是检测事务运行状态，不做处理，处理事务回查的代码部分。</p>
<p>其中<code>LocalTransactionState.COMMIT_MESSAGE</code> 为本地事务提交，代表事务过程中没有错误，消费者可以消费到该值。</p>
<p><code>LocalTransactionState.ROLLBACK_MESSAGE</code>为本地事务回滚，代表事务过程中出错，该消息将被删除，消费者无法消费该消息。</p>
<p><code>LocalTransactionState.Unknown</code>: 中间状态，它代表需要检查消息队列来确定状态，最终决定这个消息的是checkLocalTransaction这个方法。</p>
<p>消费者的内容基本不变。</p>
<p>RocketMQ它的具体事务逻辑就是 生产者发送消息成功接受后，生产者执行RocketMQ事务监听器中的executeLocalTransaction方法，根据返回的状态，来决定消息是否被消费者消费。</p>
<p>如果状态为Unknown则为待定，那么RocketMQ会每隔一段时间调用一次checkLocalTransaction方法，来决定这个消息的最终归宿。至于这个时间取决于Broker配置文件中的<code>transactionCheckInterval</code>，它的默认值是60*1000，也就是1分钟。其中还有<code>transactionCheckMax </code>,它规定了最大次数，超过这个次数，如果还返回UNKNOW，这个消息将被删除。</p>
<p>RocketMQ的事务简单来说就是，发送后检查是否将其发送前的业务完成，最终确认的操作。</p>
<p>这而举个例子：</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE &#96;s_term&#96; (
  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,
  &#96;term_year&#96; year(4) NOT NULL ,
  &#96;type&#96; int(1) NOT NULL DEFAULT &#39;1&#39; ,
  PRIMARY KEY (&#96;id&#96;)
) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这是一张订单表（假如）</p>
<p>那么我们的生产者在创建订单后将其发送消息，提醒消费者去进行核对表，然后购买…等等操作。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendTransactionMQ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Term</span> term <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Term</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    term<span class="token punctuation">.</span><span class="token function">setTermYear</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    term<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> insert <span class="token operator">=</span> termMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>term<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span>term<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	rocketMQTemplate<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span><span class="token string">"myTransactionGroup"</span><span class="token punctuation">,</span> topic<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
 <span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

     <span class="token class-name">Integer</span> termId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
     <span class="token class-name">Term</span> term <span class="token operator">=</span> termMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>termId<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"executeLocalTransaction termId="</span><span class="token operator">+</span>termId<span class="token operator">+</span><span class="token string">" term:"</span><span class="token operator">+</span>term<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>term <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> COMMIT_MESSAGE<span class="token punctuation">;</span>

     <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果前置订单创建成功这儿就会返回COMMIT_MESSAGE，该消息即可被消费者进行消费处理；</p>
<h3 id="事务消费的优化"><a href="#事务消费的优化" class="headerlink" title="事务消费的优化"></a>事务消费的优化</h3><p>上面的事务消费通常是正常的写法，但是它存在一个问题，那就是消息消费不对等。</p>
<p>当我们在生产者中发送消息后报出操作，因为Spring的@Transactional存在，那么就会导致所有的该方法内所有内容滚回。</p>
<p>但是生产者在发送消息后就自动会执行事务监听器的executeLocalTransaction方法，从而导致消息依旧可能被发送出去，并且被消费者消费…而该业务方法后抛错，导致@Transactional滚回。从而就出现了消息发送了并被消费，而订单却没被提交的情况。。。</p>
<p>对此我有个方法修护这个问题。</p>
<p>那就是<strong>将其executeLocalTransaction中的内容不要，直接返回<code>LocalTransactionState.UNKNOW</code></strong>;</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于是UNKNOW自然 就会等待周期性的触发checkLocalTransaction方法，然后进行核查。这样当业务方法发送操作后，其抛出错误，依旧可以根据周期性的触发checkLocalTransaction方法来进行 消息滚回，放置消息被发送出去。</p>
<p>但是这也有个缺点，那就是会造成消息业务处理的速度降低，因为它需要等待周期性的触发checkLocalTransaction方法。</p>
<h3 id="关于消费者组"><a href="#关于消费者组" class="headerlink" title="关于消费者组"></a>关于消费者组</h3><p>我们在设置消费者服务器监听器时，在其<code>@RocketMQMessageListener</code>中往往需要加上一个自定义的<code>consumerGroup</code>这个参数。</p>
<p>它的作用其实是分流处理，相对于管道，3个不同的consumerGroup就有3个管道，1条消息就会同时被3个consumerGroup的消费者消费。</p>
<p>当多个同业务消费者 定义为同一个 consumerGroup下，那么消息会被平均分摊处理，比如发送4条消息，2个消费者会分别处理2个消息。</p>
<p>一般情况下，我们建议一个消费者分组，仅消费一个 Topic 。，比如做订单处理的，消费者就在订单消费者组中。这样做会有两个好处：</p>
<ul>
<li>每个消费者分组职责单一，只消费一个 Topic 类型，不干其他活。</li>
<li>每个消费者分组是独占一个线程池，这样能够保证多个 Topic 隔离在不同线程池，保证隔离性，从而避免一个 Topic 消费很慢，影响到另外的 Topic 的消费。</li>
</ul>
</div>

      <!-- Post Comments -->
      
    <!-- 使用 changyan -->
<div id="changyan-comment">
    <!--PC和WAP自适应版-->
<div id="SOHUCS" sid="2021/12/21/RocketMQ/"  ></div>
<script type="text/javascript">
(function(){
var appid = 'cyvzq2tmJ';
var conf = 'e61bcf9ca7baef66559e7e33e21fe290';
var width = window.innerWidth || document.documentElement.clientWidth;
if (width < 960) {
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

</div>
<style>
    #changyan-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>

    </div>
    <!-- Copyright 版权 start -->
    <div id="copyright">
  <ul>
    <li>
      &copy;Powered By
      <a target="_blank" rel="noopener" href="https://hexo.io/" style="border-bottom: none">hexo</a>
    </li>
    <li>Author: <a style="border-bottom: none">@Zssaer</a></li>
  </ul>
  <ul>
    <li>
      <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" id="beian">蜀ICP备2021031070号</a>
    </li>
  </ul>
  
  <span id="busuanzi_container_site_pv"> 2024 </span>
  
</div>

  </div>
  <script>
    const originalTitle = document.title;
    document.title = `RocketMQ教程` + `|` + originalTitle;
  </script>
</body>



 	
</html>
